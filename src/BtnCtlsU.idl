//////////////////////////////////////////////////////////////////////
/// \mainpage ButtonControls Documentation
///
/// \section intro_sec Introduction
///
/// %ButtonControls is a collection of ActiveX controls that wrap the \c Button window class. It is
/// optimized for Visual Basic 6.0, but should also work in any other environment that supports COM
/// controls.
///
/// \section basics_sec Basics
///
/// The controls superclass the native button window class of Windows: \c Button. Although I tried to
/// wrap all features of this window class (status: Windows 10), some things may be missing. In these
/// cases you usually may use the Win32 API and handle the controls as native button windows. One of my
/// goals was it to create button controls that may be controlled via API as well as via the classes that I
/// implemented.
///
/// \section reqs_sec Requirements
///
/// %ButtonControls Unicode runs on the following operating systems:
/// - Windows XP (SP3 or later)
/// - Windows Server 2003 (SP2 or later)
/// - Windows Vista (SP2 or later)
/// - Windows Server 2008 (SP2 or later)
/// - Windows 7 (SP1 or later)
/// - Windows Server 2008 R2 (SP1 or later)
/// - Windows 8
/// - Windows Server 2012
/// - Windows 8.1
/// - Windows Server 2012 R2
/// - Windows 10
/// - Windows Server 2016
/// - Systems supported by Wine (Wine is a Win32 subsystem for alternative operating systems) - <strong>limited support</strong>
/// - ReactOS (a free Windows XP clone) - <strong>limited support</strong>
///
/// Some features have additional requirements which are mentioned in the affected feature's
/// documentation.\n
/// Limited support means, that I won't invest much work to support those systems. If a feature works on
/// a system marked with "limited support" - fine; if it does not and it's easy to fix, I'll fix it, but if
/// it's difficult to fix, I probably won't fix it. Also I will test the control much less on those systems.
///
/// \section support_sec Support
///
/// There's no entitlement to support. Period. However, you have good chances to get help if you post your
/// questions on <a href="https://github.com/TimoKunze/ButtonControls">GitHub</a> or in the
/// <a href="https://www.timosoft-software.de/forum/viewforum.php?f=25">forums</a>.\n
/// Also the project is open source, so feel free to have a look at the source code. You may modify it, but
/// please consider sharing your changes with the rest of the world.
///
/// \section lic_sec License
///
/// <pre>
///      MIT License
///
///      Copyright (c) 2006-2018 Timo Kunze
///
///      Permission is hereby granted, free of charge, to any person obtaining a copy
///      of this software and associated documentation files (the "Software"), to deal
///      in the Software without restriction, including without limitation the rights
///      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
///      copies of the Software, and to permit persons to whom the Software is
///      furnished to do so, subject to the following conditions:
///
///      The above copyright notice and this permission notice shall be included in all
///      copies or substantial portions of the Software.
///
///      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///      SOFTWARE.
/// </pre>
///
/// \section acks_sec Acknowledgements
///
/// Thanks go to:
/// - <a href="https://www.winehq.com">Wine Headquarters</a>, because Wine helped me a lot on
///   understanding how Windows is working.
/// - Microsoft, for ATL, WTL and Visual Studio - great libraries and a great IDE
/// - <a href="https://www.geoffchappell.com">Geoff Chappell</a>, for his website about undocumented Win32
///   API stuff.
/// - Igor Tandetnik, for his great help on learning ATL and WTL
/// - Dimitri van Heesch, for Doxygen
/// - <a href="http://www.zabkat.com/">Nikos Bozinis</a>, for his awesome help with the Vista drag'n'drop
///   stuff.
/// - <a href="https://www.dateicommander.de">Christian LÃ¼tgens</a>, for his great work as beta-tester
///   and for his help when I needed a 2nd opinion on some decisions.
/// - All donators
/// - For great music: Heaven Shall Burn, Arch Enemy, Machine Head, Trivium, Deadlock, Draconian, Soulfly,
///   Delain, Lacuna Coil, Ensiferum, Epica, Sirenia, Tristania, Nightwish, Battlelore, Amon Amarth, Volbeat,
///   Guns N' Roses
///
/// \section faq_sec FAQ
///
/// <strong>1. Why is the \c Font property ignored?</strong>\n
/// It isn't. My controls have a property \c UseSystemFont which defaults to \c True. This property tells
/// the control to use the system font rather than the font set by the \c Font property.\n
/// Why is this property's default \c True? Well, if I set system wide settings (like fonts) I expect all
/// applications to follow them. Unfortunately ignoring system wide settings seems to be trendy, so see
/// my decision as an educational measure.
///
/// <strong>2. Why is event xyz not fired?</strong>\n
/// Firing an event is relative time-consuming, even if the event isn't handled by the application at all.
/// Therefore I implemented a \c DisabledEvents property which can be used to deactivate certain events.\n
/// By default many events are deactivated.
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
/// \namespace BtnCtlsLibU
/// \brief <em>Contains COM definitions for the controls' public interfaces</em>
///
/// This is the Unicode version of the ButtonControls COM library.
//////////////////////////////////////////////////////////////////////


#include "olectl.h"
#include "CompilerFlags.h"
#include "DispIDs.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	// interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater
	midl_pragma warning(disable: 2039)
	// identifier length exceeds 31 characters
	midl_pragma warning(disable: 2111)
	// too many methods in the interface, requires Windows NT 4.0 SP3 or greater
	midl_pragma warning(disable: 2362)
#endif

import "oaidl.idl";
import "ocidl.idl";


[
	uuid(2AFA7915-463D-4B61-AEB7-41B1236C143E),
	version(1.10),
	helpstring("TimoSoft ButtonControls 1.10 (Unicode)")
]
library BtnCtlsLibU
{
	importlib("stdole2.tlb");


	/// \brief <em>Constants used with the \c Appearance properties</em>
	///
	/// \sa ICheckBox::Appearance, ICommandButton::Appearance, IFrame::Appearance,
	///     IOptionButton::Appearance
	[helpstring("Constants used with the 'Appearance' properties.")]
	typedef enum AppearanceConstants {
		/// \brief The control is drawn with a flat border
		[helpstring("The control is drawn flat.")]
		a2D,
		/// \brief The control is drawn with a normal 3D border
		[helpstring("The control is drawn with a normal 3D border.")]
		a3D,
		/// \brief The control is drawn with a light 3D border
		[helpstring("The control is drawn with a light 3D border.")]
		a3DLight
	} AppearanceConstants;

	/// \brief <em>Constants used with the \c BorderStyle properties</em>
	///
	/// \sa ICheckBox::BorderStyle, ICommandButton::BorderStyle, IFrame::BorderStyle,
	///     IOptionButton::BorderStyle
	[helpstring("Constants used with the 'BorderStyle' properties.")]
	typedef enum BorderStyleConstants {
		/// \brief The control is drawn without an inner border
		[helpstring("The control is drawn without an additional border.")]
		bsNone,
		/// \brief The control is drawn with an inner border
		[helpstring("The control is drawn with an additional border.")]
		bsFixedSingle
	} BorderStyleConstants;

	/// \brief <em>Constants used with the \c ICommandButton::ButtonType property</em>
	///
	/// \sa ICommandButton::ButtonType
	[helpstring("Constants used with the 'CommandButton.ButtonType' property.")]
	typedef enum ButtonTypeConstants {
		/// \brief The control is a simple command button
		[helpstring("The control is a simple command button.")]
		btCommandButton,
		/// \brief The control is a command link
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ICommandButton::CommandLinkNote
		[helpstring("The control is a command link. Requires comctl32.dll version 6.10 or higher.")]
		btCommandLink,
		/// \brief The control is a button that is split into two parts
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ICommandButton::ShowSplitLine, ICommandButton::DropDownOnRight,
		///     ICommandButton::hDropDownImageList
		[helpstring("The control is a button that is split into two parts. Requires comctl32.dll version 6.10 or higher.")]
		btSplitButton
	} ButtonTypeConstants;

	/// \brief <em>Constants used with the \c ContentType properties</em>
	///
	/// \sa ICheckBox::ContentType, ICommandButton::ContentType, IFrame::ContentType,
	///     IOptionButton::ContentType
	[helpstring("Constants used with the 'ContentType' properties.")]
	typedef enum ContentTypeConstants {
		/// \brief The control's caption consists of text
		///
		/// \sa ICheckBox::Text, ICommandButton::Text, IFrame::Text, IOptionButton::Text
		[helpstring("The control's caption consists of text.")]
		ctText,
		/// \brief The control's caption consists of a bitmap
		///
		/// \sa ICheckBox::Image, ICommandButton::Image, IFrame::Image, IOptionButton::Image
		[helpstring("The control's caption consists of a bitmap.")]
		ctBitmap,
		/// \brief The control's caption consists of an icon
		///
		/// \sa ICheckBox::Image, ICommandButton::Image, IFrame::Image, IOptionButton::Image
		[helpstring("The control's caption consists of an icon.")]
		ctIcon
	} ContentTypeConstants;

	/// \brief <em>Constants used with the \c GetControlState methods</em>
	///
	/// \sa ICheckBox::GetControlState, ICommandButton::GetControlState, IFrame::GetControlState,
	///     IOptionButton::GetControlState
	[helpstring("Constants used with the 'GetControlState' methods.")]
	typedef enum ControlStateConstants {
		/// \brief The control is unchecked
		[helpstring("The control is unchecked.")]
		csUnchecked = 0x0000 /*BST_UNCHECKED*/,
		/// \brief The control is checked
		[helpstring("The control is checked.")]
		csChecked = 0x0001 /*BST_CHECKED*/,
		/// \brief The control is in an indeterminate state
		[helpstring("The control is in an indeterminate state.")]
		csIndeterminate = 0x0002 /*BST_INDETERMINATE*/,
		/// \brief The control is pushed
		[helpstring("The control is pushed.")]
		csPushed = 0x0004 /*BST_PUSHED*/,
		/// \brief The control has the keyboard focus
		[helpstring("The control has the keyboard focus.")]
		csFocus = 0x0008 /*BST_FOCUS*/,
		/// \brief The control is currently under the mouse cursor
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		[helpstring("The control is hot, i. e. it's currently under the mouse cursor. Requires comctl32.dll version 6.0 or higher.")]
		csHot = 0x0200 /*BST_HOT*/,
		/// \brief The split button's drop-down part is pushed
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		[helpstring("The split button's drop-down part is pushed. Requires comctl32.dll version 6.10 or higher.")]
		csDropDownPushed = 0x0400 /*BST_DROPDOWNPUSHED*/
	} ControlStateConstants;

	/// \brief <em>Constants used to identify control states during custom draw</em>
	///
	/// \sa CustomDrawStageConstants, CustomDrawReturnValuesConstants, _ICheckBoxEvents::CustomDraw,
	///     _ICommandButtonEvents::CustomDraw, _IOptionButtonEvents::CustomDraw,
	///     OwnerDrawControlStateConstants
	[helpstring("Constants used to identify control states during custom draw.")]
	typedef enum CustomDrawControlStateConstants {
		/// \brief The control is selected
		[helpstring("The control is selected.")]
		cdcsSelected = 0x1 /*CDIS_SELECTED*/,
		/// \brief The control is grayed
		///
		/// \usedin The "Menu Button" sample
		[helpstring("The control is grayed.")]
		cdcsGrayed = 0x2 /*CDIS_GRAYED*/,
		/// \brief The control is disabled
		///
		/// \usedin The "Menu Button" sample
		[helpstring("The control is disabled.")]
		cdcsDisabled = 0x4 /*CDIS_DISABLED*/,
		/// \brief The control is checked
		///
		/// \remarks Current versions of Windows probably do not use this flag for button controls.
		[helpstring("The control is checked. Current versions of Windows probably do not use this flag for button controls.")]
		cdcsChecked = 0x8 /*CDIS_CHECKED*/,
		/// \brief The control has the keyboard focus
		[helpstring("The control has the keyboard focus.")]
		cdcsFocus = 0x10 /*CDIS_FOCUS*/,
		/// \brief The control is the default control
		///
		/// \remarks Current versions of Windows probably do not use this flag for button controls.
		[helpstring("The control is the default control. Current versions of Windows probably do not use this flag for button controls.")]
		cdcsDefault = 0x20 /*CDIS_DEFAULT*/,
		/// \brief The control is currently under the mouse cursor
		[helpstring("The control is hot, i. e. it's currently under the mouse cursor.")]
		cdcsHot = 0x40 /*CDIS_HOT*/,
		/// \brief The control is marked
		///
		/// \remarks Current versions of Windows probably do not use this flag for button controls.
		[helpstring("The control is marked. Current versions of Windows probably do not use this flag for button controls.")]
		cdcsMarked = 0x80 /*CDIS_MARKED*/,
		/// \brief The control is in an indeterminate state
		///
		/// \remarks Current versions of Windows probably do not use this flag for button controls.
		[helpstring("The control is in an indeterminate state. Current versions of Windows probably do not use this flag for button controls.")]
		cdcsIndeterminate = 0x100 /*CDIS_INDETERMINATE*/,
		/// \brief The control should not display keyboard cues
		[helpstring("The control should not display keyboard cues.")]
		cdcsDontShowKeyboardCues = 0x200 /*CDIS_SHOWKEYBOARDCUES*/,
		/// \brief The item is part of a control that is currently under the mouse pointer ("hot"), but the item is not "hot" itself
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          Current versions of Windows probably do not use this flag for button controls.
		[helpstring("The item is part of a control that is currently under the mouse pointer (\"hot\"), but the item is not \"hot\" itself. Requires comctl32.dll version 6.10 or higher. Current versions of Windows probably do not use this flag for button controls.")]
		cdisNearHot = 0x400 /*CDIS_NEARHOT*/,
		/// \brief The item is part of a split button that is currently under the mouse pointer ("hot"), but the item is not "hot" itself
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          Current versions of Windows don't seem to use this flag for button controls.
		[helpstring("The item is part of a split button that is currently under the mouse pointer (\"hot\"), but the item is not \"hot\" itself. Requires comctl32.dll version 6.10 or higher. Current versions of Windows don't seem to use this flag for button controls.")]
		cdisOtherSideHot = 0x800 /*CDIS_OTHERSIDEHOT*/,
		/// \brief The item is highlighted as a drop target
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          Current versions of Windows probably do not use this flag for button controls.
		[helpstring("The item is highlighted as a drop target. Requires comctl32.dll version 6.10 or higher. Current versions of Windows probably do not use this flag for button controls.")]
		cdisDropHilited = 0x1000 /*CDIS_DROPHILITED*/
	} CustomDrawControlStateConstants;

	/// \brief <em>Flags used to control further custom draw processing</em>
	///
	/// \sa CustomDrawControlStateConstants, CustomDrawStageConstants, _ICheckBoxEvents::CustomDraw,
	///     _ICommandButtonEvents::CustomDraw, _IOptionButtonEvents::CustomDraw
	[helpstring("Flags used to control further custom draw processing. They can be combined.")]
	typedef enum CustomDrawReturnValuesConstants {
		/// \brief Don't use custom draw
		///
		/// Advises the control to draw itself and to not raise any further custom draw events during the
		/// current paint cycle.
		///
		/// \usedin All custom draw samples
		[helpstring("Default processing will take place.")]
		cdrvDoDefault = 0x0 /*CDRF_DODEFAULT*/,
		/// \brief Use different font and colors
		///
		/// Advises the control to draw itself using the specified font and colors.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("Default processing will take place using the specified font and colors.")]
		cdrvNewFont = 0x2 /*CDRF_NEWFONT*/,
		/// \brief Don't draw the control
		///
		/// Advises the control to not draw itself. Use this to draw the control entirely yourself.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("The control won't draw itself.")]
		cdrvSkipDefault = 0x4 /*CDRF_SKIPDEFAULT*/,
		/// \brief Draw the background only
		///
		/// Advises the control to draw the background only.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("The control will draw the background only. Requires comctl32.dll version 6.10 or higher.")]
		cdrvDoErase = 0x8 /*CDRF_DOERASE*/,
		/// \brief Fire the custom draw event after drawing took place
		///
		/// Advises the control to fire the custom draw event after drawing took place.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("Fire the custom draw event after drawing took place.")]
		cdrvNotifyPostPaint = 0x10 /*CDRF_NOTIFYPOSTPAINT*/,
		/// \brief Fire the custom draw event for item related drawing operations
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("Fire the custom draw event for item related drawing operations. Not used.")]
		cdrvNotifyItemDraw = 0x20 /*CDRF_NOTIFYITEMDRAW*/,
		/// \brief Fire the custom draw event for sub-item related drawing operations
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("Fire the custom draw event for sub-item related drawing operations. Not used.")]
		cdrvNotifySubItemDraw = 0x20 /*CDRF_NOTIFYSUBITEMDRAW*/,
		/// \brief Fire the custom draw event after erasing took place
		///
		/// Advises the control to fire the custom draw event after erasing took place.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPreErase.
		[helpstring("Fire the custom draw event after erasing took place.")]
		cdrvNotifyPostErase = 0x40 /*CDRF_NOTIFYPOSTERASE*/,
		/// \brief Fire the custom draw event for item related erasing operations
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("Fire the custom draw event for item related erasing operations. Not used.")]
		cdrvNotifyItemErase = 0x80 /*CDRF_NOTIFYITEMERASE*/,
		/// \brief Don't draw the focus rectangle
		///
		/// Advises the control to not draw the focus rectangle.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("The control won't draw the focus rectangle. Requires comctl32.dll version 6.10 or higher.")]
		cdrvSkipPostPaint = 0x100 /*CDRF_SKIPPOSTPAINT*/
	} CustomDrawReturnValuesConstants;

	/// \brief <em>Constants used to identify custom draw stages</em>
	///
	/// \sa CustomDrawControlStateConstants, CustomDrawReturnValuesConstants, _ICheckBoxEvents::CustomDraw,
	///     _ICommandButtonEvents::CustomDraw, _IOptionButtonEvents::CustomDraw
	[helpstring("Constants used to identify custom draw stages.")]
	typedef enum CustomDrawStageConstants {
		/// \brief Before the painting cycle begins
		///
		/// \usedin All custom draw samples
		[helpstring("Before the painting cycle begins.")]
		cdsPrePaint = 0x1 /*CDDS_PREPAINT*/,
		/// \brief After the painting cycle is complete
		///
		/// \usedin The "Menu Button" sample
		[helpstring("After the painting cycle is complete.")]
		cdsPostPaint = 0x2 /*CDDS_POSTPAINT*/,
		/// \brief Before the erasing cycle begins
		[helpstring("Before the erasing cycle begins.")]
		cdsPreErase = 0x3 /*CDDS_PREERASE*/,
		/// \brief After the erasing cycle is complete
		[helpstring("After the erasing cycle is complete.")]
		cdsPostErase = 0x4 /*CDDS_POSTERASE*/,
		/// \brief The event affects a single item only and not the whole control
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("The event affects a single item only and not the whole control. Not used.")]
		cdsItem = 0x10000 /*CDDS_ITEM*/,
		/// \brief Before an item is drawn
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("Before an item is drawn. Not used.")]
		cdsItemPrePaint = cdsItem | cdsPrePaint /*CDDS_ITEMPREPAINT*/,
		/// \brief After an item has been drawn
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("After an item has been drawn. Not used.")]
		cdsItemPostPaint = cdsItem | cdsPostPaint /*CDDS_ITEMPOSTPAINT*/,
		/// \brief Before an item is erased
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("Before an item is erased. Not used.")]
		cdsItemPreErase = cdsItem | cdsPreErase /*CDDS_ITEMPREERASE*/,
		/// \brief After an item has been erased
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("After an item has been erased. Not used.")]
		cdsItemPostErase = cdsItem | cdsPostErase /*CDDS_ITEMPOSTERASE*/,
		/// \brief The event affects a single sub-item only and not the whole item
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("The event affects a single sub-item only and not the whole item. Not used.")]
		cdsSubItem = 0x20000 /*CDDS_SUBITEM*/,
		/// \brief Before a sub-item is drawn
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("Before a sub-item is drawn. Not used.")]
		cdsSubItemPrePaint = cdsSubItem | cdsItemPrePaint /*CDDS_SUBITEM | CDDS_ITEMPREPAINT*/,
		/// \brief After a sub-item has been drawn
		///
		/// \remarks This flag is not valid for button controls. It's simply defined for completeness.
		[helpstring("After a sub-item has been drawn. Not used.")]
		cdsSubItemPostPaint = cdsSubItem | cdsItemPostPaint /*CDDS_SUBITEM | CDDS_ITEMPOSTPAINT*/
	} CustomDrawStageConstants;

	/// \brief <em>Constants used to control the sizing of a split button's drop-down area</em>
	///
	/// \sa _ICommandButtonEvents::CustomDropDownAreaSize
	[helpstring("Constants used to control the sizing of a split button's drop-down area.")]
	typedef enum CustomDropDownAreaSizeReturnValuesConstants {
		/// \brief Don't use the customized bounding rectangle
		///
		/// Advises the control to use the default bounding rectangle of the drop-down area in the current
		/// paint cycle.
		[helpstring("The drop-down area will be drawn using the default bounding rectangle.")]
		cddasrvDoDefault = 0x0 /*CDRF_DODEFAULT*/,
		/// \brief Use the customized bounding rectangle
		///
		/// Advises the control to use the user-defined bounding rectangle of the drop-down area in the
		/// current paint cycle.
		[helpstring("The drop-down area will be drawn using the user-defined bounding rectangle.")]
		cddasrvSkipDefault = 0x4 /*CDRF_SKIPDEFAULT*/,
	} CustomDropDownAreaSizeReturnValuesConstants;

	/// \brief <em>Flags used with the \c DisabledEvents properties</em>
	///
	/// \sa ICheckBox::DisabledEvents, ICommandButton::DisabledEvents, IFrame::DisabledEvents,
	///     IOptionButton::DisabledEvents
	[helpstring("Flags used with the 'DisabledEvents' properties. They can be combined.")]
	typedef enum DisabledEventsConstants {
		/// \brief Mouse events won't be fired
		///
		/// The following events won't be fired: \c MouseDown, \c MouseUp, \c MouseEnter, \c MouseHover,
		/// \c MouseLeave, \c MouseMove
		///
		/// \sa _ICheckBoxEvents::MouseDown, _ICheckBoxEvents::MouseUp, _ICheckBoxEvents::MouseEnter,
		///     _ICheckBoxEvents::MouseHover, _ICheckBoxEvents::MouseLeave, _ICheckBoxEvents::MouseMove,\n
		///     _ICommandButtonEvents::MouseDown, _ICommandButtonEvents::MouseUp,
		///     _ICommandButtonEvents::MouseEnter, _ICommandButtonEvents::MouseHover,
		///     _ICommandButtonEvents::MouseLeave, _ICommandButtonEvents::MouseMove,\n
		///     _IFrameEvents::MouseDown, _IFrameEvents::MouseUp, _IFrameEvents::MouseEnter,
		///     _IFrameEvents::MouseHover, _IFrameEvents::MouseLeave, _IFrameEvents::MouseMove,\n
		///     _IOptionButtonEvents::MouseDown, _IOptionButtonEvents::MouseUp,
		///     _IOptionButtonEvents::MouseEnter, _IOptionButtonEvents::MouseHover,
		///     _IOptionButtonEvents::MouseLeave, _IOptionButtonEvents::MouseMove
		[helpstring("Disables the following events: MouseDown, MouseUp, MouseEnter, MouseHover, MouseLeave, MouseMove")]
		deMouseEvents = 0x01,
		/// \brief Click events won't be fired
		///
		/// The following events won't be fired: \c Click, \c DblClick, \c MClick, \c MDblClick,
		/// \c RClick, \c RDblClick, \c XClick, \c XDblClick
		///
		/// \sa _ICheckBoxEvents::Click, _ICheckBoxEvents::DblClick,
		///     _ICheckBoxEvents::MClick, _ICheckBoxEvents::MDblClick,
		///     _ICheckBoxEvents::RClick, _ICheckBoxEvents::RDblClick,\n
		///     _ICheckBoxEvents::XClick, _ICheckBoxEvents::XDblClick,\n
		///     _ICommandButtonEvents::Click, _ICommandButtonEvents::DblClick,
		///     _ICommandButtonEvents::MClick, _ICommandButtonEvents::MDblClick,
		///     _ICommandButtonEvents::RClick, _ICommandButtonEvents::RDblClick,\n
		///     _ICommandButtonEvents::XClick, _ICommandButtonEvents::XDblClick,\n
		///     _IFrameEvents::Click, _IFrameEvents::DblClick,
		///     _IFrameEvents::MClick, _IFrameEvents::MDblClick,
		///     _IFrameEvents::RClick, _IFrameEvents::RDblClick,\n
		///     _IFrameEvents::XClick, _IFrameEvents::XDblClick,\n
		///     _IOptionButtonEvents::Click, _IOptionButtonEvents::DblClick,
		///     _IOptionButtonEvents::MClick, _IOptionButtonEvents::MDblClick,
		///     _IOptionButtonEvents::RClick, _IOptionButtonEvents::RDblClick,
		///     _IOptionButtonEvents::XClick, _IOptionButtonEvents::XDblClick,
		[helpstring("Disables the following events: Click, DblClick, MClick, MDblClick, RClick, RDblClick, XClick, XDblClick")]
		deClickEvents = 0x02,
		/// \brief Keyboard events won't be fired
		///
		/// The following events won't be fired: \c KeyDown, \c KeyUp, \c KeyPress
		///
		/// \sa _ICheckBoxEvents::KeyDown, _ICheckBoxEvents::KeyUp,
		///     _ICheckBoxEvents::KeyPress,\n
		///     _ICommandButtonEvents::KeyDown, _ICommandButtonEvents::KeyUp,
		///     _ICommandButtonEvents::KeyPress,\n
		///     _IOptionButtonEvents::KeyDown, _IOptionButtonEvents::KeyUp,
		///     _IOptionButtonEvents::KeyPress
		[helpstring("Disables the following events: KeyDown, KeyUp, KeyPress")]
		deKeyboardEvents = 0x08,
		/// \brief The \c CustomDraw event won't be fired
		///
		/// The following event won't be fired: \c CustomDraw
		///
		/// \sa _ICheckBoxEvents::CustomDraw, _ICommandButtonEvents::CustomDraw,
		///     _IOptionButtonEvents::CustomDraw
		[helpstring("Disables the following event: CustomDraw")]
		deCustomDraw = 0x100,
		/// \brief The \c CustomDropDownAreaSize event won't be fired
		///
		/// The following event won't be fired: \c CustomDropDownAreaSize
		///
		/// \sa _ICommandButtonEvents::CustomDropDownAreaSize
		[helpstring("Disables the following event: CustomDropDownAreaSize")]
		deCustomDropDownAreaSize = 0x400
	} DisabledEventsConstants;

	/// \brief <em>Constants used with the \c IOLEDataObject::GetDropDescription and IOLEDataObject::SetDropDescription methods</em>
	///
	/// \sa IOLEDataObject::GetDropDescription, IOLEDataObject::SetDropDescription
	[helpstring("Constants used with the 'OLEDataObject.GetDropDescription' and 'OLEDataObject.SetDropDescription' methods.")]
	typedef enum DropDescriptionIconConstants {
		/// \brief No drop description is displayed
		[helpstring("No drop description is displayed.")]
		ddiNone = -1/*DROPIMAGE_INVALID*/,     // should be 8 (DROPIMAGE_NOIMAGE)
		/// \brief The drop description icon that visualizes the \c odeNone drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeNone' drop effect is displayed.")]
		ddiNoDrop = 0/*DROPIMAGE_NONE*/,
		/// \brief The drop description icon that visualizes the \c odeCopy drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeCopy' drop effect is displayed.")]
		ddiCopy = 1/*DROPIMAGE_COPY*/,
		/// \brief The drop description icon that visualizes the \c odeMove drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeMove' drop effect is displayed.")]
		ddiMove = 2/*DROPIMAGE_MOVE*/,
		/// \brief The drop description icon that visualizes the \c odeLink drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeLink' drop effect is displayed.")]
		ddiLink = 4/*DROPIMAGE_LINK*/,
		/// \brief The drop description icon that visualizes a drop, which causes a metadata change, is displayed
		[helpstring("The drop description icon that visualizes a drop, which causes a metadata change, is displayed.")]
		ddiMetadataChange = 6/*DROPIMAGE_LABEL*/,
		/// \brief The drop description icon that visualizes a warning is displayed
		[helpstring("The drop description icon that visualizes a warning is displayed.")]
		ddiWarning = 7/*DROPIMAGE_WARNING*/,
		/// \brief The default drop description is displayed
		///
		/// \remarks Requires Windows 7 or newer.
		[helpstring("The default drop description is displayed. Requires Windows 7 or newer.")]
		ddiUseDefault = 8/*DROPIMAGE_NOIMAGE*/     // should be -1 (DROPIMAGE_INVALID)
	} DropDescriptionIconConstants;

	/// \brief <em>Constants used with the \c ICommandButton::DropDownStyle property</em>
	///
	/// \sa ICommandButton::DropDownStyle
	[helpstring("Constants used with the 'CommandButton.DropDownStyle' property.")]
	typedef enum DropDownStyleConstants {
		/// \brief The drop-down arrow is an image out of an imagelist
		///
		/// \sa ICommandButton::hDropDownImageList
		[helpstring("The drop-down arrow is an image out of an imagelist.")]
		ddsImage,
		/// \brief The drop-down arrow is a character out of the font \c Webdings
		///
		/// \sa ICommandButton::DropDownGlyph
		[helpstring("The drop-down arrow is a character out of the font 'Webdings'.")]
		ddsGlyph
	} DropDownStyleConstants;

	/// \brief <em>Constants used with the extended mouse button events</em>
	///
	/// \sa _ICheckBoxEvents::MouseDown, _ICheckBoxEvents::MouseEnter,
	///     _ICheckBoxEvents::MouseHover, _ICheckBoxEvents::MouseLeave,
	///     _ICheckBoxEvents::MouseMove, _ICheckBoxEvents::MouseUp,
	///     _ICheckBoxEvents::XClick, _ICheckBoxEvents::XDblClick,\n
	///     _ICommandButtonEvents::MouseDown, _ICommandButtonEvents::MouseEnter,
	///     _ICommandButtonEvents::MouseHover, _ICommandButtonEvents::MouseLeave,
	///     _ICommandButtonEvents::MouseMove, _ICommandButtonEvents::MouseUp,
	///     _ICommandButtonEvents::XClick, _ICommandButtonEvents::XDblClick,\n
	///     _IFrameEvents::MouseDown, _IFrameEvents::MouseEnter,
	///     _IFrameEvents::MouseHover, _IFrameEvents::MouseLeave,
	///     _IFrameEvents::MouseMove, _IFrameEvents::MouseUp,
	///     _IFrameEvents::XClick, _IFrameEvents::XDblClick,\n
	///     _IOptionButtonEvents::MouseDown, _IOptionButtonEvents::MouseEnter,
	///     _IOptionButtonEvents::MouseHover, _IOptionButtonEvents::MouseLeave,
	///     _IOptionButtonEvents::MouseMove, _IOptionButtonEvents::MouseUp,
	///     _IOptionButtonEvents::XClick, _IOptionButtonEvents::XDblClick
	[helpstring("Constants used with the extended mouse button events.")]
	typedef enum ExtendedMouseButtonConstants {
		/// \brief Identifies the first extended mouse button
		[helpstring("Identifies the first extended mouse button.")]
		embXButton1 = 0x20,
		/// \brief Identifies the second extended mouse button
		[helpstring("Identifies the second extended mouse button.")]
		embXButton2 = 0x40
	} ExtendedMouseButtonConstants;

	/// \brief <em>Constants used with the \c HAlignment properties</em>
	///
	/// \sa ICheckBox::HAlignment, ICommandButton::HAlignment, IFrame::HAlignment,
	///     IOptionButton::HAlignment, VAlignmentConstants, IconAlignmentConstants
	[helpstring("Constants used with the 'HAlignment' properties.")]
	typedef enum HAlignmentConstants {
		/// \brief The control's caption is left-aligned
		[helpstring("The control's caption is left-aligned.")]
		halLeft,
		/// \brief The control's caption is horizontally centered
		[helpstring("The control's caption is horizontally centered.")]
		halCenter,
		/// \brief The control's caption is right-aligned
		[helpstring("The control's caption is right-aligned.")]
		halRight
	} HAlignmentConstants;

	/// \brief <em>Constants used with the \c IconAlignment properties</em>
	///
	/// \sa ICheckBox::IconAlignment, ICommandButton::IconAlignment, IFrame::IconAlignment,
	///     IOptionButton::IconAlignment, HAlignmentConstants, VAlignmentConstants
	[helpstring("Constants used with the 'IconAlignment' properties.")]
	typedef enum IconAlignmentConstants {
		/// \brief The control's icon is left-aligned
		[helpstring("The control's icon is left-aligned.")]
		ialLeft,
		/// \brief The control's icon is right-aligned
		[helpstring("The control's icon is right-aligned.")]
		ialRight,
		/// \brief The control's icon is top-aligned
		[helpstring("The control's icon is top-aligned.")]
		ialTop,
		/// \brief The control's icon is bottom-aligned
		[helpstring("The control's icon is bottom-aligned.")]
		ialBottom,
		/// \brief The control's icon is centered
		[helpstring("The control's icon is centered.")]
		ialCenter
	} IconAlignmentConstants;

	/// \brief <em>Constants used with the \c MousePointer properties</em>
	///
	/// \sa ICheckBox::MousePointer, ICommandButton::MousePointer, IFrame::MousePointer,
	///     IOptionButton::MousePointer
	[helpstring("Constants used with the 'MousePointer' properties.")]
	typedef enum MousePointerConstants {
		/// \brief The default mouse cursor is used
		[helpstring("The default mouse cursor is used.")]
		mpDefault,
		/// \brief The default arrow is used as mouse cursor
		[helpstring("The default arrow is used as mouse cursor.")]
		mpArrow,
		/// \brief A cross is used as mouse cursor
		[helpstring("A cross is used as mouse cursor.")]
		mpCross,
		/// \brief A vertical beam (like in textboxes) is used as mouse cursor
		[helpstring("A vertical beam (like in textboxes) is used as mouse cursor.")]
		mpIBeam,
		/// \brief An icon is used as mouse cursor
		[helpstring("An icon is used as mouse cursor.")]
		mpIcon,
		/// \brief A mouse cursor indicating window sizing is used
		[helpstring("A mouse cursor indicating window sizing is used.")]
		mpSize,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-right or lower-left corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-right or lower-left corner is used.")]
		mpSizeNESW,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its upper or
		/// lower border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper or lower border is used.")]
		mpSizeNS,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-left or lower-right corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-left or lower-right corner is used.")]
		mpSizeNWSE,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its left or
		/// right border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's left or right border is used.")]
		mpSizeEW,
		/// \brief An arrow pointing upwardly is used as mouse cursor
		[helpstring("An arrow pointing upwardly is used as mouse cursor.")]
		mpUpArrow,
		/// \brief An hourglass is used as mouse cursor.
		[helpstring("An hourglass is used as mouse cursor.")]
		mpHourglass,
		/// \brief An mouse cursor indicating that the control can't be a drop target is used
		[helpstring("An mouse cursor indicating that the control can't be a drop target is used.")]
		mpNoDrop,
		/// \brief The default arrow with a small hourglass is used as mouse cursor
		[helpstring("The default arrow with a small hourglass is used as mouse cursor.")]
		mpArrowHourglass,
		/// \brief The default arrow with a small question mark is used as mouse cursor
		[helpstring("The default arrow with a small question mark is used as mouse cursor.")]
		mpArrowQuestion,
		/// \brief A mouse cursor indicating window sizing to all directions is used
		[helpstring("A mouse cursor indicating window sizing to all directions is used.")]
		mpSizeAll,
		/// \brief A hand typically used for hyperlinks is used as mouse cursor
		[helpstring("A hand typically used for hyperlinks is used as mouse cursor.")]
		mpHand,
		/// \brief A mouse cursor indicating that the program waits for some media is used
		[helpstring("A mouse cursor indicating that the program waits for some media is used.")]
		mpInsertMedia,
		/// \brief A mouse cursor indicating scrolling to all directions is used
		[helpstring("A mouse cursor indicating scrolling to all directions is used.")]
		mpScrollAll,
		/// \brief A mouse cursor indicating scrolling upwardly is used
		[helpstring("A mouse cursor indicating scrolling upwardly is used.")]
		mpScrollN,
		/// \brief A mouse cursor indicating scrolling to the window's upper-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-right corner is used.")]
		mpScrollNE,
		/// \brief A mouse cursor indicating scrolling to the window's right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's right border is used.")]
		mpScrollE,
		/// \brief A mouse cursor indicating scrolling to the window's lower-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-right corner is used.")]
		mpScrollSE,
		/// \brief A mouse cursor indicating scrolling downwards is used
		[helpstring("A mouse cursor indicating scrolling downwards is used.")]
		mpScrollS,
		/// \brief A mouse cursor indicating scrolling to the window's lower-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-left corner is used.")]
		mpScrollSW,
		/// \brief A mouse cursor indicating scrolling to the window's left border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left border is used.")]
		mpScrollW,
		/// \brief A mouse cursor indicating scrolling to the window's upper-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-left corner is used.")]
		mpScrollNW,
		/// \brief A mouse cursor indicating scrolling upwardly or downwards is used
		[helpstring("A mouse cursor indicating scrolling upwardly or downwards is used.")]
		mpScrollNS,
		/// \brief A mouse cursor indicating scrolling to the window's left or right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left or right border is used.")]
		mpScrollEW,
		/// \brief The custom mouse cursor defined by the \c MouseIcon property is used
		[helpstring("The custom mouse cursor defined by the MouseIcon property is used.")]
		mpCustom = 0x63
	} MousePointerConstants;

	/// \brief <em>Constants used with OLE drag'n'drop</em>
	///
	/// \sa _ICheckBoxEvents::OLEDragEnter, _ICheckBoxEvents::OLEDragMouseMove,
	///     _ICheckBoxEvents::OLEDragDrop,\n
	///     _ICommandButtonEvents::OLEDragEnter, _ICommandButtonEvents::OLEDragMouseMove,
	///     _ICommandButtonEvents::OLEDragDrop,\n
	///     _IFrameEvents::OLEDragEnter, _IFrameEvents::OLEDragMouseMove,
	///     _IFrameEvents::OLEDragDrop,\n
	///     _IOptionButtonEvents::OLEDragEnter, _IOptionButtonEvents::OLEDragMouseMove,
	///     _IOptionButtonEvents::OLEDragDrop
	[helpstring("Constants used with the OLEDrag* events.")]
	typedef enum OLEDropEffectConstants {
		/// \brief No OLE drag and drop operation has occurred or will occur
		[helpstring("No OLE drag and drop operation has occurred or will occur.")]
		odeNone = 0 /*DROPEFFECT_NONE*/,
		/// \brief A copy has occured or will occur
		[helpstring("A copy has occured or will occur.")]
		odeCopy = 1 /*DROPEFFECT_COPY*/,
		/// \brief A move has occured or will occur
		[helpstring("A move has occured or will occur.")]
		odeMove = 2 /*DROPEFFECT_MOVE*/,
		/// \brief A link has occured or will occur
		[helpstring("A link has occured or will occur.")]
		odeLink = 4 /*DROPEFFECT_LINK*/,
		/// \brief Combination of \c odeCopy and \c odeMove
		[helpstring("Combination of 'odeCopy' and 'odeMove'.")]
		odeCopyOrMove = odeCopy | odeMove,
		/// \brief The drop target window has scrolled or will scroll
		[helpstring("The drop target window has scrolled or will scroll.")]
		odeScroll = 0x80000000 /*DROPEFFECT_SCROLL*/
	} OLEDropEffectConstants;

	/// \brief <em>Constants used to identify the required drawing action during owner-drawing</em>
	///
	/// \sa _ICheckBoxEvents::OwnerDraw, _ICommandButtonEvents::OwnerDraw, _IFrameEvents::OwnerDraw,
	///     _IOptionButtonEvents::OwnerDraw
	[helpstring("Constants used to identify the required drawing action during owner-drawing.")]
	typedef enum OwnerDrawActionConstants {
		/// \brief The entire control needs to be drawn
		[helpstring("The entire control needs to be drawn.")]
		odaDrawEntire = 0x1 /*ODA_DRAWENTIRE*/,
		/// \brief The control's selection state has changed
		[helpstring("The control's selection state has changed.")]
		odaSelectionStateChanged = 0x2 /*ODA_SELECT*/,
		/// \brief The control has gained or lost the keyboard focus
		[helpstring("The control has gained or lost the keyboard focus.")]
		odaFocusChanged = 0x4 /*ODA_FOCUS*/
	} OwnerDrawActionConstants;

	/// \brief <em>Constants used to identify control states during owner-drawing</em>
	///
	/// \sa _ICheckBoxEvents::OwnerDraw, _ICommandButtonEvents::OwnerDraw, _IFrameEvents::OwnerDraw,
	///     _IOptionButtonEvents::OwnerDraw, CustomDrawControlStateConstants
	[helpstring("Constants used to identify control states during owner-drawing.")]
	typedef enum OwnerDrawControlStateConstants {
		/// \brief The control is in no special state
		[helpstring("The control is in no special state.")]
		odcsNormal = 0x0,
		/// \brief The control is pushed
		[helpstring("The control is pushed.")]
		odcsPushed = 0x1,
		/// \brief The control is selected
		[helpstring("The control is selected.")]
		odcsSelected = 0x2,
		/// \brief The control is in an indeterminate state
		[helpstring("The control is in an indeterminate state.")]
		odcsIndeterminate = 0x4,
		/// \brief The control has the keyboard focus
		[helpstring("The control has the keyboard focus.")]
		odcsFocus = 0x8,
		/// \brief The control is in 'hot' state, i. e. it's below the mouse cursor
		[helpstring("The control is in 'hot' state, i. e. it's below the mouse cursor.")]
		odcsHot = 0x10,
		/// \brief The control is disabled
		[helpstring("The control is disabled.")]
		odcsDisabled = 0x20,
		/// \brief The control is drawn without the keyboard accelerator cues
		[helpstring("The control is drawn without the keyboard accelerator cues.")]
		odcsNoAccelerator = 0x100,
		/// \brief The control is drawn without focus indicator cues
		[helpstring("The control is drawn without focus indicator cues.")]
		odcsNoFocusRectangle = 0x200
	} OwnerDrawControlStateConstants;

	/// \brief <em>Flags used with the \c RightToLeft properties</em>
	///
	/// \sa ICheckBox::RightToLeft, ICommandButton::RightToLeft, IFrame::RightToLeft,
	///     IOptionButton::RightToLeft
	[helpstring("Flags used with the 'RightToLeft' properties. They can be combined.")]
	typedef enum RightToLeftConstants {
		/// \brief Read text from right to left
		///
		/// The items' text is read from right to left, but the general layout is left to right.
		[helpstring("The items' text is read from right to left, but the general layout is left to right.")]
		rtlText = 1,
		/// \brief Use a right to left layout
		///
		/// The general layout is right to left.
		[helpstring("The general layout is right to left.")]
		rtlLayout = 2
	} RightToLeftConstants;

	/// \brief <em>Constants used with the \c SelectionState property</em>
	///
	/// \sa ICheckBox::SelectionState
	[helpstring("Constants used with the 'SelectionState' property.")]
	typedef enum SelectionStateConstants {
		/// \brief The checkbox is cleared
		[helpstring("The checkbox is cleared.")]
		ssUnchecked,
		/// \brief The checkbox is checked
		[helpstring("The checkbox is checked.")]
		ssChecked,
		/// \brief The checkbox is grayed, indicating an indeterminate state
		///
		/// \remarks This value is valid only if the \c TriState property is set to \c True.
		///
		/// \sa ICheckBox::TriState
		[helpstring("The checkbox is grayed, indicating an indeterminate state. This value is valid only if the 'TriState' property is set to 'True'.")]
		ssIndeterminate
	} SelectionStateConstants;

	/// \brief <em>Constants used with the \c Style properties</em>
	///
	/// \sa ICheckBox::Style, ICommandButton::Style, IFrame::Style, IOptionButton::Style
	[helpstring("Constants used with the 'Style' properties.")]
	typedef enum StyleConstants {
		/// \brief The control is drawn in common style
		[helpstring("The control is drawn in common style.")]
		sNormal,
		/// \brief The control is drawn in flat style
		///
		/// \remarks This value isn't supported for themed controls.
		[helpstring("The control is drawn in flat style. This value isn't supported for themed controls.")]
		sFlat,
		/// \brief The control raises the \c OwnerDraw event if it must be drawn
		///
		/// \sa _ICheckBoxEvents::OwnerDraw, _ICheckBoxEvents::CustomDraw,\n
		///     _ICommandButtonEvents::OwnerDraw, _ICommandButtonEvents::CustomDraw,\n
		///     _IFrameEvents::OwnerDraw,\n
		///     _IOptionButtonEvents::OwnerDraw, _IOptionButtonEvents::CustomDraw
		[helpstring("The control raises the 'OwnerDraw' event if it must be drawn.")]
		sOwnerDrawn
	} StyleConstants;

	/// \brief <em>Constants used with the \c VAlignment properties</em>
	///
	/// \sa ICheckBox::VAlignment, ICommandButton::VAlignment, IOptionButton::VAlignment,
	///     HAlignmentConstants, IconAlignmentConstants
	[helpstring("Constants used with the 'VAlignment' properties.")]
	typedef enum VAlignmentConstants {
		/// \brief The control's caption is top-aligned
		[helpstring("The control's caption is top-aligned.")]
		valTop,
		/// \brief The control's caption is vertically centered
		[helpstring("The control's caption is vertically centered.")]
		valCenter,
		/// \brief The control's caption is bottom-aligned
		[helpstring("The control's caption is bottom-aligned.")]
		valBottom
	} VAlignmentConstants;


	/// \brief <em>Holds the coordinates of a rectangle's opposing corners</em>
	///
	/// \sa _ICheckBoxEvents::CustomDraw, _ICheckBoxEvents::OwnerDraw,\n
	///     _ICommandButtonEvents::CustomDraw, _ICommandButtonEvents::OwnerDraw,\n
	///     _IFrameEvents::OwnerDraw,\n
	///     _IOptionButtonEvents::CustomDraw, _IOptionButtonEvents::OwnerDraw
	// NOTE: If we change the UUID, we also need to update _I*Events_CP.h!
	[helpstring("Holds a rectangle's position and size."), uuid(0E7EE607-CD5D-4974-98AF-250D1A31A3F5)]
	typedef struct RECTANGLE
	{
		/// \brief <em>Holds the position of the rectangle's left border in pixels</em>
		[helpstring("Holds the position of the rectangle's left border in pixels.")]
		OLE_XPOS_PIXELS Left;
		/// \brief <em>Holds the position of the rectangle's upper border in pixels</em>
		[helpstring("Holds the position of the rectangle's upper border in pixels.")]
		OLE_YPOS_PIXELS Top;
		/// \brief <em>Holds the position of the rectangle's right border in pixels</em>
		[helpstring("Holds the position of the rectangle's right border in pixels.")]
		OLE_XPOS_PIXELS Right;
		/// \brief <em>Holds the position of the rectangle's lower border in pixels</em>
		[helpstring("Holds the position of the rectangle's lower border in pixels.")]
		OLE_YPOS_PIXELS Bottom;
	} RECTANGLE;


	/// \interface IOLEDataObject
	/// \brief <em>Wraps the \c IDataObject interface</em>
	///
	/// This interface provides easy access to data being transferred using the \c IDataObject interface.
	///
	/// \sa _IOLEDataObjectEvents,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
	[
		object,
		uuid(02865BEA-79B3-4b7a-9BEA-4FF36828C676),
		dual,
		nonextensible,
		helpstring("IOLEDataObject interface"),
		pointer_default(unique)
	]
	interface IOLEDataObject : IDispatch
	{
		/// \brief <em>Deletes the contents of the \c OLEDataObject object</em>
		///
		/// \remarks This method will succeed only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
		[id(DISPID_ODO_CLEAR), helpstring("Deletes the contents of the 'OLEDataObject' object.")]
		HRESULT Clear(void);
		/// \brief <em>Retrieves the best format settings from the \c OLEDataObject object</em>
		///
		/// Call this method to retrieve data format settings that match best with the data format, that you
		/// actually want to work with. Set the parameters to the data format settings you want to work with.
		/// The method will set them to the settings you should use.
		///
		/// \param[in,out] formatID An integer value specifying the data format. Valid values are those defined
		///                by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///                registered using the \c RegisterClipboardFormat API function.
		/// \param[in,out] index An integer value that is assigned to the internal \c FORMATETC struct's
		///                \c lindex member. Usually you pass -1 here, but some formats like
		///                \c CFSTR_FILECONTENTS require multiple \c FORMATETC structs for the same format. In
		///                such cases you'll give each struct of this format a separate index.
		/// \param[in,out] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
		///                struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
		///                Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \sa GetData, GetFormat,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETCANONICALFORMAT), helpstring("Call this method to retrieve data format settings that match best with the data format, that you actually want to work with.")]
		HRESULT GetCanonicalFormat([in, out] LONG* formatID, [in, out] LONG* Index, [in, out] LONG* dataOrViewAspect);
		/// \brief <em>Retrieves data from the \c OLEDataObject object</em>
		///
		/// Retrieves data from the \c OLEDataObject object, that has the specified format.
		///
		/// \param[in] formatID An integer value specifying the format of the data to retrieve. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return The data that has the specified format.
		///
		/// \remarks This method will fail, if the \c OLEDataObject object does not contain data of the
		///          specified format.
		///
		/// \sa GetCanonicalFormat, GetFormat, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETDATA), helpstring("Retrieves data from the 'OLEDataObject' object.")]
		HRESULT GetData([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT* pData);
		/// \brief <em>Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object</em>
		///
		/// Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object. The drop description
		/// describes what will happen if the user drops the dragged data at the current position. It is
		/// displayed at the bottom of the drag image.
		///
		/// \param[in,out] targetDescription Receives the description of the current drop target.
		/// \param[in,out] actionDescription Receives the description of the whole drop action, i. e. a string
		///                like <em>"Copy to %1"</em> where <em>"Copy to"</em> is the description of the current
		///                drop effect and <em>"%1"</em> is the placeholder for the drop target description
		///                specified by \c targetDescription.
		/// \param[in,out] icon Receives the icon used to visualize the current drop effect. Any of the values
		///                defined by the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa SetDropDescription, ICheckBox::SupportOLEDragImages, ICommandButton::SupportOLEDragImages,
		///     IFrame::SupportOLEDragImages, IOptionButton::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_GETDROPDESCRIPTION), helpstring("Retrieves the 'DROPDESCRIPTION' data stored by the 'OLEDataObject' object. Requires Windows Vista or newer.")]
		HRESULT GetDropDescription([in, out, optional] VARIANT* targetDescription, [in, out, optional] VARIANT* actionDescription, [in, out, defaultvalue(0)] DropDescriptionIconConstants* Icon);
		/// \brief <em>Retrieves whether the \c OLEDataObject object contains data in a specific format</em>
		///
		/// \param[in] formatID An integer value specifying the format to check for. Valid values are those
		///            defined by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///            registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return \c True, if the \c OLEDataObject object contains data in the specified format;
		///         otherwise \c False.
		///
		/// \sa GetCanonicalFormat, GetData, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETFORMAT), helpstring("Retrieves whether the 'OLEDataObject' object contains data in a specific format.")]
		HRESULT GetFormat([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT_BOOL* pFormatAvailable);
		/// \brief <em>Inserts data into the \c OLEDataObject object using the specified format</em>
		///
		/// \param[in] formatID An integer value specifying the format of the data being passed. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] data The data to insert. If not specified, the \c OLESetData event will be raised if
		///            data of the specified format is requested from the \c OLEDataObject object.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \remarks The \c data parameter is optional only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa GetData, Clear,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_SETDATA), helpstring("Inserts data into the 'OLEDataObject' object using the specified format.")]
		HRESULT SetData([in] LONG formatID, [in, optional] VARIANT data, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect);
		/// \brief <em>Sets the drop description displayed below the drag image</em>
		///
		/// Sets the \c DROPDESCRIPTION data. The drop description describes what will happen if the user drops
		/// the dragged data at the current position. It is displayed at the bottom of the drag image.
		///
		/// \param[in] targetDescription The description of the current drop target.
		/// \param[in] actionDescription The description of the whole drop action, i. e. a string like <em>"Copy
		///            to %1"</em> where <em>"Copy to"</em> is the description of the current drop effect and
		///            <em>"%1"</em> is the placeholder for the drop target description specified by
		///            \c targetDescription.
		/// \param[in] icon The icon used to visualize the current drop effect. Any of the values defined by
		///            the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa GetDropDescription, ICheckBox::SupportOLEDragImages, ICommandButton::SupportOLEDragImages,
		///     IFrame::SupportOLEDragImages, IOptionButton::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_SETDROPDESCRIPTION), helpstring("Sets the drop description displayed below the drag image. Requires Windows Vista or newer.")]
		HRESULT SetDropDescription([in, optional] VARIANT targetDescription, [in, optional] VARIANT actionDescription, [in, defaultvalue(ddiNone)] DropDescriptionIconConstants Icon);
	}


	/// \interface _IOLEDataObjectEvents
	/// \brief <em>The \c OLEDataObject class' events interface</em>
	///
	/// This interface defines all events the \c OLEDataObject class may raise.
	///
	/// \sa IOLEDataObject
	[
		uuid(8E4D6F9C-8F92-46a7-B17A-F22B13D461DA),
		helpstring("IOLEDataObject-event-interface")
	]
	dispinterface _IOLEDataObjectEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEDataObject class</em>
	///
	/// This COM class implements the \c IOLEDataObject and \c _IOLEDataObjectEvents interfaces.
	///
	/// \sa IOLEDataObject, _IOLEDataObjectEvents
	[
		uuid(570B2D14-0D8D-4eac-928D-E60361A096DF),
		version(1.10),
		noncreatable,
		helpstring("OLEDataObject Class 1.10 (Unicode)")
	]
	coclass OLEDataObject
	{
		[default] interface IOLEDataObject;
		[default, source] dispinterface _IOLEDataObjectEvents;
	};


	/// \interface ICheckBox
	/// \brief <em>The main interface (checkbox)</em>
	///
	/// This is the checkbox control's main interface. It wraps the control window.
	///
	/// \sa _ICheckBoxEvents
	[
		object,
		uuid(BA3FA853-66C3-4543-BAB7-B73EAD6A4A2E),
		dual,
		nonextensible,
		helpstring("ICheckBox interface"),
		pointer_default(unique)
	]
	interface ICheckBox : IDispatch
	{
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, PushLike, Style, AppearanceConstants
		[propget, id(DISPID_CHKBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_CHKBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CHKBOX_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CHKBOX_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CHKBOX_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Controls how the control reacts to mouse clicks</em>
		///
		/// Retrieves or sets whether the checkmark state is changed automatically if the user clicks on the
		/// control. If set to \c True, it is changed automatically; otherwise not.
		///
		/// \sa SelectionState, TriState, _ICheckBoxEvents::Click
		[propget, id(DISPID_CHKBOX_AUTOTOGGLECHECKMARK), helpstring("Retrieves or sets whether the checkmark state is changed automatically if the user clicks on the control.")]
		HRESULT AutoToggleCheckMark([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_AUTOTOGGLECHECKMARK), helpstring("Retrieves or sets whether the checkmark state is changed automatically if the user clicks on the control.")]
		HRESULT AutoToggleCheckMark([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \remarks This property isn't supported for themed checkboxes.
		///
		/// \sa ForeColor
		[propget, id(DISPID_CHKBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed checkboxes.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CHKBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed checkboxes.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, PushLike, Style, BorderStyleConstants
		[propget, id(DISPID_CHKBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_CHKBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CHKBOX_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CHKBOX_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls the checkmark's location relative to the control's caption</em>
		///
		/// Retrieves or sets whether the control's checkmark is drawn to the right of the text specified by
		/// the \c Text property. If set to \c True, it is drawn to the right; otherwise to the left.
		///
		/// \sa RightToLeft, Text
		[propget, id(DISPID_CHKBOX_CHECKMARKONRIGHT), helpstring("Retrieves or sets whether the control's checkmark is drawn to the right of the text specified by the 'Text' property.")]
		HRESULT CheckMarkOnRight([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_CHECKMARKONRIGHT), helpstring("Retrieves or sets whether the control's checkmark is drawn to the right of the text specified by the 'Text' property.")]
		HRESULT CheckMarkOnRight([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the type of the control's caption</em>
		///
		/// Retrieves or sets what the control's caption consists of. Any of the values defined by the
		/// \c ContentTypeConstants enumeration is valid.
		///
		/// \sa Image, Text, ContentTypeConstants
		[propget, id(DISPID_CHKBOX_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([out, retval] ContentTypeConstants* pValue);
		[propput, id(DISPID_CHKBOX_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([in] ContentTypeConstants newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_CHKBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_CHKBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large
		/// changes on the control may increase performance.
		/// If set to \c False, the control will redraw itself automatically; otherwise not.
		[propget, id(DISPID_CHKBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_CHKBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the caption.
		///
		/// \sa UseSystemFont, Text, ForeColor
		[propget, id(DISPID_CHKBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_CHKBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_CHKBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \remarks This property isn't supported for themed checkboxes.
		///
		/// \sa BackColor, Text, Font
		[propget, id(DISPID_CHKBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed checkboxes.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CHKBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed checkboxes.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the horizontal alignment of the control's caption</em>
		///
		/// Retrieves or sets the horizontal alignment of the control's caption. Any of the values defined by
		/// the \c HAlignmentConstants enumeration is valid.
		///
		/// \sa Text, VAlignment, IconAlignment, HAlignmentConstants
		[propget, id(DISPID_CHKBOX_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_CHKBOX_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies the control's associated imagelist</em>
		///
		/// Retrieves or sets the handle to the imagelist containing the control's icons. If set to 0, no
		/// icon is drawn.\n
		/// The icon's index in the imagelist specifies the control state it is used for:
		/// - 0 - Used if the checkbox is in no special state.
		/// - 1 - Used if the checkbox is in 'hot' state, i. e. it's below the mouse cursor.
		/// - 2 - Used if the checkbox is pressed.
		/// - 3 - Used if the checkbox is disabled.
		/// - (4 - Used if the checkbox is the dialog's default button.)
		/// - 5 - Used on Tablet PCs (I don't know when).
		///
		/// If the imagelist contains only one icon, it is used for all control states. If it contains more
		/// than one, but less than five (six on Tablet PCs), no icon will be drawn if the control is in a
		/// state that no icon is specified for.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          The previously set image list does NOT get destroyed automatically.
		///
		/// \sa Image, Text, IconAlignment, UseImprovedImageListSupport, IconIndex, GetIdealSize
		[propget, id(DISPID_CHKBOX_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_CHKBOX_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system
		/// hover time is used.
		///
		/// \sa _ICheckBoxEvents::MouseHover
		[propget, id(DISPID_CHKBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_CHKBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _ICheckBoxEvents::RecreatedControlWindow, _ICheckBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_CHKBOX_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified
		/// by the \c hImageList property). Any of the values defined by the \c IconAlignmentConstants
		/// enumeration is valid.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa hImageList, HAlignment, VAlignment, IconAlignmentConstants
		[propget, id(DISPID_CHKBOX_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([out, retval] IconAlignmentConstants* pValue);
		[propput, id(DISPID_CHKBOX_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([in] IconAlignmentConstants newValue);
		/// \brief <em>Specifies the control's icons</em>
		///
		/// Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the
		/// \c hImageList property. The control can use a different icon for each control state.
		///
		/// \param[in] controlState The control state for the icon index shall be retrieved or set. If set to
		///            -1, the icon index is applied for all control states. The following control states
		///            exist:
		///            - Icon 0 - Used if the checkbox is in no special state.
		///            - Icon 1 - Used if the checkbox is in 'hot' state, i. e. it's below the mouse cursor.
		///            - Icon 2 - Used if the checkbox is pressed.
		///            - Icon 3 - Used if the checkbox is disabled.
		///            - (Icon 4 - Used if the checkbox is the dialog's default button.)
		///            - Icon 5 - Used on Tablet PCs (I don't know when).
		///            If a state's icon index is set to -1, no icon is drawn for this state.
		///
		/// \remarks This property is ignored if the \c UseImprovedImageListSupport is set to \c False.
		///
		/// \sa UseImprovedImageListSupport, hImageList
		[propget, id(DISPID_CHKBOX_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [out, retval] LONG* pValue);
		[propput, id(DISPID_CHKBOX_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [in] LONG newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginLeft, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_CHKBOX_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_CHKBOX_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginTop, hImageList
		[propget, id(DISPID_CHKBOX_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginRight, hImageList
		[propget, id(DISPID_CHKBOX_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the bitmap or icon displayed as caption</em>
		///
		/// Retrieves or sets the image that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctBitmap or \c ctIcon.
		///
		/// \remarks The image does NOT get destroyed automatically by the control.\n
		///          Due to limitations in Windows' \c Button window class, checkboxes displaying a bitmap or
		///          icon won't use Windows XP themes.
		///
		/// \sa ContentType, Text, hImageList
		[propget, id(DISPID_CHKBOX_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, checkboxes using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_CHKBOX_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, checkboxes using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([in] OLE_HANDLE newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CHKBOX_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_CHKBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_CHKBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_CHKBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_CHKBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_CHKBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the control displays text in multiple lines</em>
		///
		/// Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to
		/// fit on a single line. If set to \c True, the text may be wrapped; otherwise not.
		///
		/// \sa Text
		[propget, id(DISPID_CHKBOX_MULTILINE), helpstring("Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to fit on a single line..")]
		HRESULT MultiLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_MULTILINE), helpstring("Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to fit on a single line.")]
		HRESULT MultiLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the event gets fired; otherwise not.
		///
		/// \sa _ICheckBoxEvents::ContextMenu
		[propget, id(DISPID_CHKBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_CHKBOX_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the control is drawn like being pushed</em>
		///
		/// Retrieves or sets whether the checkbox is drawn like being pushed. If set to \c True, it is drawn
		/// like being pushed; otherwise not.
		///
		/// \sa Click, GetControlState
		[propget, id(DISPID_CHKBOX_PUSHED), helpstring("Retrieves or sets whether the checkbox is drawn like being pushed.")]
		HRESULT Pushed([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_PUSHED), helpstring("Retrieves or sets whether the checkbox is drawn like being pushed.")]
		HRESULT Pushed([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's appearance</em>
		///
		/// Retrieves or sets whether the checkbox is drawn like a push button. If set to \c True, it is
		/// drawn like a push button; otherwise it is drawn like a common checkbox.
		///
		/// \sa Appearance, BorderStyle, Style
		[propget, id(DISPID_CHKBOX_PUSHLIKE), helpstring("Retrieves or sets whether the checkbox is drawn like a push button.")]
		HRESULT PushLike([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_PUSHLIKE), helpstring("Retrieves or sets whether the checkbox is drawn like a push button.")]
		HRESULT PushLike([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _ICheckBoxEvents::OLEDragEnter
		[propget, id(DISPID_CHKBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa CheckMarkOnRight, RightToLeftConstants
		[propget, id(DISPID_CHKBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_CHKBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the state of the control's checkmark</em>
		///
		/// Retrieves or sets the state of the control's checkmark. Any of the values defined by the
		/// \c SelectionStateConstants enumeration is valid.
		///
		/// \sa AutoToggleCheckMark, TriState, GetControlState, SelectionStateConstants,
		///     _ICheckBoxEvents::SelectionStateChanged
		[propget, id(DISPID_CHKBOX_SELECTIONSTATE), helpstring("Retrieves or sets the state of the control's checkmark."), bindable, immediatebind, requestedit, displaybind, defaultbind]
		HRESULT SelectionState([out, retval] SelectionStateConstants* pValue);
		[propput, id(DISPID_CHKBOX_SELECTIONSTATE), helpstring("Retrieves or sets the state of the control's checkmark."), bindable, immediatebind, requestedit, displaybind, defaultbind]
		HRESULT SelectionState([in] SelectionStateConstants newValue);
		/// \brief <em>Controls the control's appearance</em>
		///
		/// Retrieves or sets the control's drawing style. Any of the values defined by the \c StyleConstants
		/// enumeration is valid.
		///
		/// \sa Appearance, BorderStyle, PushLike, StyleConstants
		[propget, id(DISPID_CHKBOX_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([out, retval] StyleConstants* pValue);
		[propput, id(DISPID_CHKBOX_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([in] StyleConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_CHKBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_CHKBOX_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's caption</em>
		///
		/// Retrieves or sets the text that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctText.
		///
		/// \sa HAlignment, VAlignment, MultiLine, ForeColor, Font, ContentType, Image, hImageList,
		///     GetIdealSize
		[propget, id(DISPID_CHKBOX_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_CHKBOX_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the bottom margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginLeft, TextMarginRight, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_CHKBOX_TEXTMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginBottom([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_TEXTMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginBottom([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the left margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginBottom, TextMarginRight, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_CHKBOX_TEXTMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginLeft([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_TEXTMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginLeft([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the right margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginBottom, TextMarginLeft, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_CHKBOX_TEXTMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginRight([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_TEXTMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginRight([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the top margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginBottom, TextMarginLeft, TextMarginRight, Text, GetIdealSize
		[propget, id(DISPID_CHKBOX_TEXTMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginTop([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CHKBOX_TEXTMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginTop([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether the control supports 3 states</em>
		///
		/// Retrieves or sets whether the control's checkmark supports 3 states. If set to \c True, it supports
		/// 3 states; otherwise only 2.
		///
		/// \sa SelectionState, AutoToggleCheckMark
		[propget, id(DISPID_CHKBOX_TRISTATE), helpstring("Retrieves or sets whether the control's checkmark supports 3 states.")]
		HRESULT TriState([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_TRISTATE), helpstring("Retrieves or sets whether the control's checkmark supports 3 states.")]
		HRESULT TriState([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses code that makes usage of image lists easier</em>
		///
		/// The Windows native button control supports assignment of an image list to display an icon on the
		/// button, but it requires the icon to be the first one in the image list. For this reason each button
		/// needs its own image list, so the more buttons with icons are used, the more image lists have to be
		/// created and managed. This leads to bloated code.\n
		/// TimoSoft ButtonControls can work around this issue and allow the client application to specify the
		/// icons used by a button individually, so that all buttons can share the same image list. However,
		/// this feature slightly changes the control's behavior, so it must be activated explicitly to keep
		/// backward compatibility.\n
		/// If this property is set to \c True, the work-around is activated; otherwise not.
		///
		/// \remarks This property cannot be set at run-time.
		///
		/// \sa hImageList, IconIndex
		[propget, id(DISPID_CHKBOX_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_CHKBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHKBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the vertical alignment of the control's caption</em>
		///
		/// Retrieves or sets the vertical alignment of the control's caption. Any of the values defined by the
		/// \c VAlignmentConstants enumeration is valid.
		///
		/// \sa Text, HAlignment, IconAlignment, VAlignmentConstants
		[propget, id(DISPID_CHKBOX_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the control's caption.")]
		HRESULT VAlignment([out, retval] VAlignmentConstants* pValue);
		[propput, id(DISPID_CHKBOX_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the control's caption.")]
		HRESULT VAlignment([in] VAlignmentConstants newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_CHKBOX_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_CHKBOX_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Clicks the checkbox by code</em>
		///
		/// \sa _ICheckBoxEvents::Click
		[id(DISPID_CHKBOX_CLICK), helpstring("Clicks the checkbox by code.")]
		HRESULT Click(void);
		/// \brief <em>Retrieves a bit field describing the control's state</em>
		///
		/// \return A bit field of constants defined by the \c ControlStateConstants enumeration, that
		///         describe the control's state.
		///
		/// \sa Pushed, SelectionState, ControlStateConstants
		[id(DISPID_CHKBOX_GETCONTROLSTATE), helpstring("Retrieves a bit field describing the control's state.")]
		HRESULT GetControlState([out, retval] ControlStateConstants* pControlState);
		/// \brief <em>Retrieves the control's optimal size</em>
		///
		/// Calculates the rectangle that best fits the control's text and image, if an imagelist is present.
		///
		/// \param[out] idealWidth The control's optimal width in pixels.
		/// \param[out] idealHeight The control's optimal height in pixels.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text, hImageList, TextMarginBottom, TextMarginLeft, TextMarginRight, TextMarginTop
		[id(DISPID_CHKBOX_GETIDEALSIZE), helpstring("Calculates the rectangle that best fits the control's text and image, if an imagelist is present. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT GetIdealSize([in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* idealWidth, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* idealHeight);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_CHKBOX_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_CHKBOX_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_CHKBOX_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _ICheckBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_CHKBOX_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _ICheckBoxEvents
	/// \brief <em>The \c CheckBox class' events interface</em>
	///
	/// This interface defines all events the \c CheckBox class may raise.
	///
	/// \sa ICheckBox
	[
		uuid(2203BCD4-689B-47e3-BFC8-55B38DE33C56),
		helpstring("ICheckBox-event-interface")
	]
	dispinterface _ICheckBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The control's selection state was changed</em>
			///
			/// Will be fired after the control's selection state was changed.
			///
			/// \param[in] previousSelectionState The control's previous selection state.
			/// \param[in] newSelectionState The control's new selection state.
			///
			/// \sa ICheckBox::SelectionState, SelectionStateConstants
			[id(DISPID_CHKBOXE_SELECTIONSTATECHANGED), helpstring("Will be fired after the control's selection state was changed.")]
			void SelectionStateChanged(SelectionStateConstants previousSelectionState, SelectionStateConstants newSelectionState);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			///
			/// \sa RClick
			[id(DISPID_CHKBOXE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>Custom drawing should be done here</em>
			///
			/// Will be fired after the control processed a \c NM_CUSTOMDRAW notification allowing custom
			/// drawing of the control's content.
			///
			/// \param[in] drawStage Specifies the stage of custom drawing this event was raised for. Any of
			///            the values defined by the \c CustomDrawStageConstants enumeration is valid.
			/// \param[in] controlState Specifies the control's current state (focused, selected etc.). Most of
			///            the values defined by the \c CustomDrawControlStateConstants enumeration are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			/// \param[in,out] furtherProcessing Controls further drawing. Most of the values defined by the
			///                \c CustomDrawReturnValuesConstants enumeration are valid.
			///
			/// \remarks Requires comctl32.dll version 6.0 or higher.\n
			///          This event may be disabled.
			///
			/// \sa OwnerDraw, RECTANGLE, CustomDrawStageConstants, CustomDrawControlStateConstants,
			///     CustomDrawReturnValuesConstants, ICheckBox::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms673590.aspx">NM_CUSTOMDRAW (button)</a>
			[id(DISPID_CHKBOXE_CUSTOMDRAW), helpstring("Will be fired after the control processed a 'NM_CUSTOMDRAW' notification allowing custom drawing of the control. Requires comctl32.dll version 6.0 or higher. This event may be disabled.")]
			void CustomDraw(CustomDrawStageConstants drawStage, CustomDrawControlStateConstants controlState, LONG hDC, RECTANGLE* drawingRectangle, CustomDrawReturnValuesConstants* furtherProcessing);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, ICheckBox::hWnd
			[id(DISPID_CHKBOXE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c ICheckBox::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, ICheckBox::HoverTime, ExtendedMouseButtonConstants,
			///     ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, ExtendedMouseButtonConstants,
			///     ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, ICheckBox::RegisterForOLEDragDrop,
			///     ICheckBox::FinishOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_CHKBOXE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, ICheckBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_CHKBOXE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, ICheckBox::RegisterForOLEDragDrop
			[id(DISPID_CHKBOXE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, ICheckBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_CHKBOXE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control must be drawn</em>
			///
			/// Will be fired if the \c Style property is set to \c sOwnerDrawn and the control needs to be
			/// drawn.
			///
			/// \param[in] requiredAction Specifies the required drawing action. Any combination of the values
			///            defined by the \c OwnerDrawActionConstants enumeration is valid.
			/// \param[in] controlState Specifies the control's current state (focused, selected etc.). Any
			///            combination of the values defined by the \c OwnerDrawControlStateConstants enumeration
			///            are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			///
			/// \sa ICheckBox::Style, CustomDraw, RECTANGLE, OwnerDrawActionConstants,
			///     OwnerDrawControlStateConstants
			[id(DISPID_CHKBOXE_OWNERDRAW), helpstring("Will be fired if the 'Style' property is set to 'sOwnerDrawn' and the control needs to be drawn.")]
			void OwnerDraw(OwnerDrawActionConstants requiredAction, OwnerDrawControlStateConstants controlState, LONG hDC, RECTANGLE* drawingRectangle);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, ICheckBox::hWnd
			[id(DISPID_CHKBOXE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_CHKBOXE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants, ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants,
			///     ICheckBox::DisabledEvents
			[id(DISPID_CHKBOXE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \brief <em>The \c CheckBox class</em>
	///
	/// The checkbox control's main COM class. It implements the \c ICheckBox and
	/// \c _ICheckBoxEvents interfaces.
	///
	/// \sa ICheckBox, _ICheckBoxEvents
	[
		uuid(3ED31350-A47C-4020-94A3-7884BA10F656),
		version(1.10),
		helpstring("CheckBox Control 1.10 (Unicode)")
	]
	coclass CheckBox
	{
		[default] interface ICheckBox;
		[default, source] dispinterface _ICheckBoxEvents;
	};


	/// \interface ICommandButton
	/// \brief <em>The main interface (command button)</em>
	///
	/// This is the command button control's main interface. It wraps the control window.
	///
	/// \sa _ICommandButtonEvents
	[
		object,
		uuid(5D145E18-17CE-436f-83EE-C4064737107B),
		dual,
		nonextensible,
		helpstring("ICommandButton interface"),
		pointer_default(unique)
	]
	interface ICommandButton : IDispatch
	{
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, Style, ButtonType, AppearanceConstants
		[propget, id(DISPID_CMDBTN_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_CMDBTN_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CMDBTN_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CMDBTN_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CMDBTN_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \remarks This property affects owner-drawn buttons only.
		///
		/// \sa ForeColor, Style
		[propget, id(DISPID_CMDBTN_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property affects owner-drawn buttons only.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CMDBTN_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property affects owner-drawn buttons only.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, Style, ButtonType, BorderStyleConstants
		[propget, id(DISPID_CMDBTN_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_CMDBTN_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CMDBTN_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Specifies the button's sub-type</em>
		///
		/// Retrieves or sets the control's command button sub-type. Any of the values defined by the
		/// \c ButtonTypeConstants enumeration is valid.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa Appearance, BorderStyle, Style, ButtonTypeConstants
		[propget, id(DISPID_CMDBTN_BUTTONTYPE), helpstring("Retrieves or sets the control's command button sub-type. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT ButtonType([out, retval] ButtonTypeConstants* pValue);
		[propput, id(DISPID_CMDBTN_BUTTONTYPE), helpstring("Retrieves or sets the control's command button sub-type. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT ButtonType([in] ButtonTypeConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CMDBTN_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the additional text displayed in a command link button</em>
		///
		/// Retrieves or sets the text that is displayed below the button's caption if the \c ButtonType
		/// property is set to \c btCommandLink.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ButtonType, Text
		[propget, id(DISPID_CMDBTN_COMMANDLINKNOTE), helpstring("Retrieves or sets the text that is displayed below the button's caption if the 'ButtonType' property is set to 'btCommandLink'. Requires comctl32.dll version 6.10 or higher."), bindable, requestedit, displaybind]
		HRESULT CommandLinkNote([out, retval] BSTR* pValue);
		[propput, id(DISPID_CMDBTN_COMMANDLINKNOTE), helpstring("Retrieves or sets the text that is displayed below the button's caption if the 'ButtonType' property is set to 'btCommandLink'. Requires comctl32.dll version 6.10 or higher."), bindable, requestedit, displaybind]
		HRESULT CommandLinkNote([in] BSTR newValue);
		/// \brief <em>Controls the type of the control's caption</em>
		///
		/// Retrieves or sets what the control's caption consists of. Any of the values defined by the
		/// \c ContentTypeConstants enumeration is valid.
		///
		/// \sa Image, Text, ContentTypeConstants
		[propget, id(DISPID_CMDBTN_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([out, retval] ContentTypeConstants* pValue);
		[propput, id(DISPID_CMDBTN_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([in] ContentTypeConstants newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_CMDBTN_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_CMDBTN_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large
		/// changes on the control may increase performance.
		/// If set to \c False, the control will redraw itself automatically; otherwise not.
		[propget, id(DISPID_CMDBTN_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the height of the control's drop-down arrow</em>
		///
		/// Retrieves or sets the height (in pixels) of the drop-down part of a split button. If set to 0, the
		/// default height is used.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa DropDownArrowWidth, ButtonType, KeepDropDownArrowAspectRatio,
		///     _ICommandButtonEvents::CustomDropDownAreaSize
		[propget, id(DISPID_CMDBTN_DROPDOWNARROWHEIGHT), helpstring("Retrieves or sets the height (in pixels) of the drop-down part of a split button. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownArrowHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_DROPDOWNARROWHEIGHT), helpstring("Retrieves or sets the height (in pixels) of the drop-down part of a split button. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownArrowHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the width of the control's drop-down arrow</em>
		///
		/// Retrieves or sets the width (in pixels) of the drop-down part of a split button.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa DropDownArrowHeight, ButtonType, KeepDropDownArrowAspectRatio,
		///     _ICommandButtonEvents::CustomDropDownAreaSize
		[propget, id(DISPID_CMDBTN_DROPDOWNARROWWIDTH), helpstring("Retrieves or sets the width (in pixels) of the drop-down part of a split button. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownArrowWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_DROPDOWNARROWWIDTH), helpstring("Retrieves or sets the width (in pixels) of the drop-down part of a split button. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownArrowWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the appearance of the control's drop-down arrow</em>
		///
		/// Retrieves or sets the code of the character, that is displayed as drop-down arrow in a split
		/// button, if the \c DropDownStyle property is set to \c ddsGlyph.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ButtonType, DropDownStyle, hDropDownImageList
		[propget, id(DISPID_CMDBTN_DROPDOWNGLYPH), helpstring("Retrieves or sets the code of the character, that is displayed as drop-down arrow in a split button, if the 'DropDownStyle' property is set to 'ddsGlyph'. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownGlyph([out, retval] SHORT* pValue);
		[propput, id(DISPID_CMDBTN_DROPDOWNGLYPH), helpstring("Retrieves or sets the code of the character, that is displayed as drop-down arrow in a split button, if the 'DropDownStyle' property is set to 'ddsGlyph'. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownGlyph([in] SHORT newValue);
		/// \brief <em>Controls the location of the control's drop-down arrow</em>
		///
		/// Retrieves or sets whether the drop-down part of a split button is drawn to the right of its
		/// caption. If set to \c True, the separator is displayed to the right; otherwise to the left of the
		/// caption.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ButtonType
		[propget, id(DISPID_CMDBTN_DROPDOWNONRIGHT), helpstring("Retrieves or sets whether the drop-down part of a split button is drawn to the right of its caption. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownOnRight([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_DROPDOWNONRIGHT), helpstring("Retrieves or sets whether the drop-down part of a split button is drawn to the right of its caption. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownOnRight([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the split button's drop-down part is drawn like being pushed</em>
		///
		/// Retrieves or sets whether the drop-down part of a split button is drawn like being pushed. If set
		/// to \c True, it is drawn like being pushed; otherwise not.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ButtonType, Pushed
		[propget, id(DISPID_CMDBTN_DROPDOWNPUSHED), helpstring("Retrieves or sets whether the drop-down part of a split button is drawn like being pushed. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownPushed([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_DROPDOWNPUSHED), helpstring("Retrieves or sets whether the drop-down part of a split button is drawn like being pushed. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownPushed([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the appearance of the control's drop-down arrow</em>
		///
		/// Retrieves or sets which type of drop-down arrow to use in a split button. Any of the values defined
		/// by the \c DropDownStyleConstants enumeration is valid.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ButtonType, DropDownGlyph, hDropDownImageList, DropDownStyleConstants
		[propget, id(DISPID_CMDBTN_DROPDOWNSTYLE), helpstring("Retrieves or sets which type of drop-down arrow to use in a split button. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownStyle([out, retval] DropDownStyleConstants* pValue);
		[propput, id(DISPID_CMDBTN_DROPDOWNSTYLE), helpstring("Retrieves or sets which type of drop-down arrow to use in a split button. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DropDownStyle([in] DropDownStyleConstants newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_CMDBTN_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the caption.
		///
		/// \sa UseSystemFont, Text, ForeColor
		[propget, id(DISPID_CMDBTN_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_CMDBTN_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_CMDBTN_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \remarks This property affects owner-drawn buttons only.
		///
		/// \sa BackColor, Text, Font
		[propget, id(DISPID_CMDBTN_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property affects owner-drawn buttons only.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CMDBTN_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property affects owner-drawn buttons only.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the horizontal alignment of the control's caption</em>
		///
		/// Retrieves or sets the horizontal alignment of the control's caption. Any of the values defined by
		/// the \c HAlignmentConstants enumeration is valid.
		///
		/// \sa Text, VAlignment, IconAlignment, HAlignmentConstants
		[propget, id(DISPID_CMDBTN_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_CMDBTN_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies the control's associated imagelist containing the drop-down arrows</em>
		///
		/// Retrieves or sets the handle to the imagelist containing the icons, that are displayed as drop-down
		/// arrow in a split button, if the \c DropDownStyle property is set to \c ddsImage. If set to 0, no
		/// icon is drawn.\n
		/// The icon's index in the imagelist specifies the control state it is used for:
		/// - 0 - Used if the button is in no special state.
		/// - 1 - Used if the button is in 'hot' state, i. e. it's below the mouse cursor.
		/// - 2 - Used if the button is pressed.
		/// - 3 - Used if the button is disabled.
		/// - 4 - Used if the button is the dialog's default button.
		/// - 5 - Used on Tablet PCs (I don't know when).
		///
		/// If the imagelist contains only one icon, it is used for all control states. If it contains more
		/// than one, but less than five (six on Tablet PCs), no icon will be drawn if the control is in a
		/// state that no icon is specified for.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          The previously set image list does NOT get destroyed automatically.
		///
		/// \sa hImageList, ButtonType, DropDownStyle, DropDownGlyph
		[propget, id(DISPID_CMDBTN_HDROPDOWNIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the icons, that are displayed as drop-down arrow in a split button, if the 'DropDownStyle' property is set to 'ddsImage'. Requires comctl32.dll version 6.10 or higher."), nonbrowsable]
		HRESULT hDropDownImageList([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_CMDBTN_HDROPDOWNIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the icons, that are displayed as drop-down arrow in a split button, if the 'DropDownStyle' property is set to 'ddsImage'. Requires comctl32.dll version 6.10 or higher."), nonbrowsable]
		HRESULT hDropDownImageList([in] OLE_HANDLE newValue);
		/// \brief <em>Specifies the control's associated imagelist</em>
		///
		/// Retrieves or sets the handle to the imagelist containing the control's icons. If set to 0, no
		/// icon is drawn.\n
		/// The icon's index in the imagelist specifies the control state it is used for:
		/// - 0 - Used if the button is in no special state.
		/// - 1 - Used if the button is in 'hot' state, i. e. it's below the mouse cursor.
		/// - 2 - Used if the button is pressed.
		/// - 3 - Used if the button is disabled.
		/// - 4 - Used if the button is the dialog's default button.
		/// - 5 - Used on Tablet PCs (I don't know when).
		///
		/// If the imagelist contains only one icon, it is used for all control states. If it contains more
		/// than one, but less than five (six on Tablet PCs), no icon will be drawn if the control is in a
		/// state that no icon is specified for.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          The previously set image list does NOT get destroyed automatically.
		///
		/// \sa hDropDownImageList, UseImprovedImageListSupport, IconIndex, Image, Text, IconAlignment,
		///     ShowRightsElevationIcon, GetIdealSize
		[propget, id(DISPID_CMDBTN_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_CMDBTN_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system
		/// hover time is used.
		///
		/// \sa _ICommandButtonEvents::MouseHover
		[propget, id(DISPID_CMDBTN_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_CMDBTN_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _ICommandButtonEvents::RecreatedControlWindow, _ICommandButtonEvents::DestroyedControlWindow
		[propget, id(DISPID_CMDBTN_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified
		/// by the \c hImageList property). Any of the values defined by the \c IconAlignmentConstants
		/// enumeration is valid.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa hImageList, HAlignment, VAlignment, IconAlignmentConstants
		[propget, id(DISPID_CMDBTN_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([out, retval] IconAlignmentConstants* pValue);
		[propput, id(DISPID_CMDBTN_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([in] IconAlignmentConstants newValue);
		/// \brief <em>Specifies the control's icons</em>
		///
		/// Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the
		/// \c hImageList property. The control can use a different icon for each control state.
		///
		/// \param[in] controlState The control state for the icon index shall be retrieved or set. If set to
		///            -1, the icon index is applied for all control states. The following control states
		///            exist:
		///            - Icon 0 - Used if the button is in no special state.
		///            - Icon 1 - Used if the button is in 'hot' state, i. e. it's below the mouse cursor.
		///            - Icon 2 - Used if the button is pressed.
		///            - Icon 3 - Used if the button is disabled.
		///            - Icon 4 - Used if the button is the dialog's default button.
		///            - Icon 5 - Used on Tablet PCs (I don't know when).
		///            If a state's icon index is set to -1, no icon is drawn for this state.
		///
		/// \remarks This property is ignored if the \c UseImprovedImageListSupport is set to \c False.
		///
		/// \sa UseImprovedImageListSupport, hImageList
		[propget, id(DISPID_CMDBTN_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [out, retval] LONG* pValue);
		[propput, id(DISPID_CMDBTN_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [in] LONG newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginLeft, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_CMDBTN_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_CMDBTN_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginTop, hImageList
		[propget, id(DISPID_CMDBTN_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginRight, hImageList
		[propget, id(DISPID_CMDBTN_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the bitmap or icon displayed as caption</em>
		///
		/// Retrieves or sets the image that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctBitmap or \c ctIcon.
		///
		/// \remarks The image does NOT get destroyed automatically by the control.\n
		///          Due to limitations in Windows' \c Button window class, command buttons displaying a bitmap
		///          or icon won't use Windows XP themes.
		///
		/// \sa ContentType, Text, hImageList, ShowRightsElevationIcon
		[propget, id(DISPID_CMDBTN_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, command buttons using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_CMDBTN_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, command buttons using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([in] OLE_HANDLE newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CMDBTN_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Controls the appearance of the control's drop-down arrow</em>
		///
		/// Retrieves or sets whether the drop-down arrow of a split button is shrinked or stretched, so that
		/// its aspect ratio remains the same when changing the drop-down arrow's size. If set to \c True,
		/// the aspect ratio remains the same; otherwise not.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ButtonType, DropDownArrowHeight, DropDownArrowWidth
		[propget, id(DISPID_CMDBTN_KEEPDROPDOWNARROWASPECTRATIO), helpstring("Retrieves or sets whether the drop-down arrow of a split button is shrinked or stretched, so that its aspect ratio remains the same when changing the drop-down arrow's size. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT KeepDropDownArrowAspectRatio([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_KEEPDROPDOWNARROWASPECTRATIO), helpstring("Retrieves or sets whether the drop-down arrow of a split button is shrinked or stretched, so that its aspect ratio remains the same when changing the drop-down arrow's size. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT KeepDropDownArrowAspectRatio([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_CMDBTN_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_CMDBTN_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_CMDBTN_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_CMDBTN_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_CMDBTN_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the control displays text in multiple lines</em>
		///
		/// Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to
		/// fit on a single line. If set to \c True, the text may be wrapped; otherwise not.
		///
		/// \sa Text
		[propget, id(DISPID_CMDBTN_MULTILINE), helpstring("Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to fit on a single line..")]
		HRESULT MultiLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_MULTILINE), helpstring("Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to fit on a single line.")]
		HRESULT MultiLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the event gets fired; otherwise not.
		///
		/// \sa _ICommandButtonEvents::ContextMenu
		[propget, id(DISPID_CMDBTN_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_CMDBTN_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the control is drawn like being pushed</em>
		///
		/// Retrieves or sets whether the button is drawn like being pushed. If set to \c True, it is drawn
		/// like being pushed; otherwise not.
		///
		/// \sa Click, GetControlState
		[propget, id(DISPID_CMDBTN_PUSHED), helpstring("Retrieves or sets whether the button is drawn like being pushed.")]
		HRESULT Pushed([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_PUSHED), helpstring("Retrieves or sets whether the button is drawn like being pushed.")]
		HRESULT Pushed([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _ICommandButtonEvents::OLEDragEnter
		[propget, id(DISPID_CMDBTN_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_CMDBTN_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_CMDBTN_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies whether the control displays the Vista LUA icon</em>
		///
		/// Retrieves or sets whether the control displays an icon, which indicates, that clicking the control
		/// triggers an action, that requires elevated rights. If set to \c True, the icon is displayed;
		/// otherwise not.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa hImageList
		[propget, id(DISPID_CMDBTN_SHOWRIGHTSELEVATIONICON), helpstring("Retrieves or sets whether the control displays an icon, which indicates, that clicking the control triggers an action, that requires elevated rights. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT ShowRightsElevationIcon([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_SHOWRIGHTSELEVATIONICON), helpstring("Retrieves or sets whether the control displays an icon, which indicates, that clicking the control triggers an action, that requires elevated rights. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT ShowRightsElevationIcon([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the appearance of a drop-down button</em>
		///
		/// Retrieves or sets whether the two parts of a split button are visually separated by a line. If set
		/// to \c True, the separator is displayed; otherwise not.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa ButtonType
		[propget, id(DISPID_CMDBTN_SHOWSPLITLINE), helpstring("Retrieves or sets whether the two parts of a split button are visually separated by a line. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT ShowSplitLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_SHOWSPLITLINE), helpstring("Retrieves or sets whether the two parts of a split button are visually separated by a line. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT ShowSplitLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's appearance</em>
		///
		/// Retrieves or sets the control's drawing style. Any of the values defined by the \c StyleConstants
		/// enumeration is valid.
		///
		/// \sa Appearance, BorderStyle, ButtonType, StyleConstants
		[propget, id(DISPID_CMDBTN_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([out, retval] StyleConstants* pValue);
		[propput, id(DISPID_CMDBTN_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([in] StyleConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_CMDBTN_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_CMDBTN_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's caption</em>
		///
		/// Retrieves or sets the text that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctText.
		///
		/// \sa CommandLinkNote, HAlignment, VAlignment, MultiLine, ForeColor, Font, ContentType, Image,
		///     hImageList, GetIdealSize
		[propget, id(DISPID_CMDBTN_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_CMDBTN_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the bottom margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows seem to support text margins when calculating the ideal size
		///          only.
		///
		/// \sa TextMarginLeft, TextMarginRight, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_CMDBTN_TEXTMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginBottom([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_TEXTMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginBottom([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the left margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows seem to support text margins when calculating the ideal size
		///          only.
		///
		/// \sa TextMarginBottom, TextMarginRight, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_CMDBTN_TEXTMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginLeft([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_TEXTMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginLeft([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the right margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows seem to support text margins when calculating the ideal size
		///          only.
		///
		/// \sa TextMarginBottom, TextMarginLeft, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_CMDBTN_TEXTMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginRight([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_TEXTMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginRight([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the top margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows seem to support text margins when calculating the ideal size
		///          only.
		///
		/// \sa TextMarginBottom, TextMarginLeft, TextMarginRight, Text, GetIdealSize
		[propget, id(DISPID_CMDBTN_TEXTMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginTop([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CMDBTN_TEXTMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows seem to support text margins when calculating the ideal size only.")]
		HRESULT TextMarginTop([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether the control uses code that makes usage of image lists easier</em>
		///
		/// The Windows native button control supports assignment of an image list to display an icon on the
		/// button, but it requires the icon to be the first one in the image list. For this reason each button
		/// needs its own image list, so the more buttons with icons are used, the more image lists have to be
		/// created and managed. This leads to bloated code.\n
		/// TimoSoft ButtonControls can work around this issue and allow the client application to specify the
		/// icons used by a button individually, so that all buttons can share the same image list. However,
		/// this feature slightly changes the control's behavior, so it must be activated explicitly to keep
		/// backward compatibility.\n
		/// If this property is set to \c True, the work-around is activated; otherwise not.
		///
		/// \remarks This property cannot be set at run-time.
		///
		/// \sa hImageList, IconIndex
		[propget, id(DISPID_CMDBTN_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_CMDBTN_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CMDBTN_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the vertical alignment of the control's caption</em>
		///
		/// Retrieves or sets the vertical alignment of the control's caption. Any of the values defined by the
		/// \c VAlignmentConstants enumeration is valid.
		///
		/// \sa Text, HAlignment, IconAlignment, VAlignmentConstants
		[propget, id(DISPID_CMDBTN_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the control's caption.")]
		HRESULT VAlignment([out, retval] VAlignmentConstants* pValue);
		[propput, id(DISPID_CMDBTN_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the control's caption.")]
		HRESULT VAlignment([in] VAlignmentConstants newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_CMDBTN_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_CMDBTN_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Clicks the button by code</em>
		///
		/// \sa _ICommandButtonEvents::Click
		[id(DISPID_CMDBTN_CLICK), helpstring("Clicks the button by code.")]
		HRESULT Click(void);
		/// \brief <em>Retrieves a bit field describing the control's state</em>
		///
		/// \return A bit field of constants defined by the \c ControlStateConstants enumeration, that
		///         describe the control's state.
		///
		/// \sa Pushed, ControlStateConstants
		[id(DISPID_CMDBTN_GETCONTROLSTATE), helpstring("Retrieves a bit field describing the control's state.")]
		HRESULT GetControlState([out, retval] ControlStateConstants* pControlState);
		/// \brief <em>Retrieves the control's optimal size</em>
		///
		/// Calculates the rectangle that best fits the control's text and image, if an imagelist is present.
		///
		/// \param[out] idealWidth The control's optimal width in pixels.
		/// \param[out] idealHeight The control's optimal height in pixels.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text, hImageList, TextMarginBottom, TextMarginLeft, TextMarginRight, TextMarginTop
		[id(DISPID_CMDBTN_GETIDEALSIZE), helpstring("Calculates the rectangle that best fits the control's text and image, if an imagelist is present. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT GetIdealSize([in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* idealWidth, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* idealHeight);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_CMDBTN_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_CMDBTN_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_CMDBTN_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _ICommandButtonEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_CMDBTN_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _ICommandButtonEvents
	/// \brief <em>The \c CommandButton class' events interface</em>
	///
	/// This interface defines all events the \c CommandButton class may raise.
	///
	/// \sa ICommandButton
	[
		uuid(1BDAEB99-3A89-410a-AAA7-3BEFA485C20B),
		helpstring("ICommandButton-event-interface")
	]
	dispinterface _ICommandButtonEvents
	{
		properties:
		methods:
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This is the control's default event.\n
			///          This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			///
			/// \sa RClick
			[id(DISPID_CMDBTNE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>Custom drawing should be done here</em>
			///
			/// Will be fired after the control processed a \c NM_CUSTOMDRAW notification allowing custom
			/// drawing of the control's content.
			///
			/// \param[in] drawStage Specifies the stage of custom drawing this event was raised for. Any of
			///            the values defined by the \c CustomDrawStageConstants enumeration is valid.
			/// \param[in] controlState Specifies the control's current state (focused, selected etc.). Most of
			///            the values defined by the \c CustomDrawControlStateConstants enumeration are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			/// \param[in,out] furtherProcessing Controls further drawing. Most of the values defined by the
			///                \c CustomDrawReturnValuesConstants enumeration are valid.
			///
			/// \remarks Requires comctl32.dll version 6.0 or higher.\n
			///          This event may be disabled.
			///
			/// \sa OwnerDraw, CustomDropDownAreaSize, RECTANGLE, CustomDrawStageConstants,
			///     CustomDrawControlStateConstants, CustomDrawReturnValuesConstants,
			///     ICommandButton::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms673590.aspx">NM_CUSTOMDRAW (button)</a>
			[id(DISPID_CMDBTNE_CUSTOMDRAW), helpstring("Will be fired after the control processed a 'NM_CUSTOMDRAW' notification allowing custom drawing of the control. Requires comctl32.dll version 6.0 or higher. This event may be disabled.")]
			void CustomDraw(CustomDrawStageConstants drawStage, CustomDrawControlStateConstants controlState, LONG hDC, RECTANGLE* drawingRectangle, CustomDrawReturnValuesConstants* furtherProcessing);
			/// \brief <em>Customizing the size of a split button's drop-down area should be done here</em>
			///
			/// Will be fired if the system needs the bounding rectangle of a split button's drop-down area. This
			/// event is raised in each drawing cycle.
			///
			/// \param[in] clientRectangle The bounding rectangle of the control's client area.
			/// \param[in,out] commandButtonAreaRectangle The bounding rectangle of the control's command button
			///                area. You may customize the area of the button, that is displayed and handled as
			///                the command button area by changing this rectangle.
			/// \param[in,out] dropDownAreaRectangle The bounding rectangle of the control's drop-down area. You
			///                may customize the area of the button, that is displayed and handled as the
			///                drop-down area by changing this rectangle.
			/// \param[in,out] furtherProcessing Controls how the rectangle specified by \c dropDownAreaRectangle
			///                is used. Any of the values defined by the
			///                \c CustomDropDownAreaSizeReturnValuesConstants enumeration is valid.
			///
			/// \remarks Requires comctl32.dll version 6.10 or higher.\n
			///          This event may be disabled.
			///
			/// \sa CustomDraw, ICommandButton::ButtonType, ICommandButton::DropDownArrowHeight,
			///     ICommandButton::DropDownArrowWidth, RECTANGLE, CustomDropDownAreaSizeReturnValuesConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_CUSTOMDROPDOWNAREASIZE), helpstring("Will be fired if the system needs the bounding rectangle of a split button's drop-down area. Requires comctl32.dll version 6.10 or higher. This event may be disabled.")]
			void CustomDropDownAreaSize(RECTANGLE* clientRectangle, RECTANGLE* commandButtonAreaRectangle, RECTANGLE* dropDownAreaRectangle, CustomDropDownAreaSizeReturnValuesConstants* furtherProcessing);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, ICommandButton::hWnd
			[id(DISPID_CMDBTNE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The drop-down menu should be displayed</em>
			///
			/// Will be fired if a split button's drop-down menu should displayed.
			///
			/// \param[in] buttonRectangle The button's bounding rectangle (in pixels). Use it to position the
			///            drop-down menu.
			///
			/// \remarks This event isn't raised, if the \c ShowSplitLine property is set to \c False.\n
			///          Requires comctl32.dll version 6.10 or higher.
			///
			/// \sa Click, ICommandButton::ButtonType, ICommandButton::ShowSplitLine
			[id(DISPID_CMDBTNE_DROPDOWN), helpstring("Will be fired if a split button's drop-down menu should displayed. Requires comctl32.dll version 6.10 or higher.")]
			void DropDown(RECTANGLE* buttonRectangle);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c ICommandButton::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, ICommandButton::HoverTime, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp,
			///     ICommandButton::RegisterForOLEDragDrop, ICommandButton::FinishOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_CMDBTNE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter,
			///     ICommandButton::RegisterForOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_CMDBTNE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave,
			///     ICommandButton::RegisterForOLEDragDrop
			[id(DISPID_CMDBTNE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, ICommandButton::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_CMDBTNE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control must be drawn</em>
			///
			/// Will be fired if the \c Style property is set to \c sOwnerDrawn and the control needs to be
			/// drawn.
			///
			/// \param[in] requiredAction Specifies the required drawing action. Any combination of the values
			///            defined by the \c OwnerDrawActionConstants enumeration is valid.
			/// \param[in] controlState Specifies the control's current state (focused, selected etc.). Any
			///            combination of the values defined by the \c OwnerDrawControlStateConstants enumeration
			///            are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			///
			/// \sa ICommandButton::Style, CustomDraw, RECTANGLE, OwnerDrawActionConstants,
			///     OwnerDrawControlStateConstants
			[id(DISPID_CMDBTNE_OWNERDRAW), helpstring("Will be fired if the 'Style' property is set to 'sOwnerDrawn' and the control needs to be drawn.")]
			void OwnerDraw(OwnerDrawActionConstants requiredAction, OwnerDrawControlStateConstants controlState, LONG hDC, RECTANGLE* drawingRectangle);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, ICommandButton::hWnd
			[id(DISPID_CMDBTNE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_CMDBTNE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants,
			///     ICommandButton::DisabledEvents
			[id(DISPID_CMDBTNE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \brief <em>The \c CommandButton class</em>
	///
	/// The command button control's main COM class. It implements the \c ICommandButton and
	/// \c _ICommandButtonEvents interfaces.
	///
	/// \sa ICommandButton, _ICommandButtonEvents
	[
		uuid(F18BF4EE-2CC6-4f00-A915-85CC7D4971D1),
		version(1.10),
		helpstring("CommandButton Control 1.10 (Unicode)")
	]
	coclass CommandButton
	{
		[default] interface ICommandButton;
		[default, source] dispinterface _ICommandButtonEvents;
	};


	/// \interface IFrame
	/// \brief <em>The main interface (frame)</em>
	///
	/// This is the frame control's main interface. It wraps the control window.
	///
	/// \sa _IFrameEvents
	[
		object,
		uuid(468023E6-D60C-4f07-B29F-5B6D9D8D875C),
		dual,
		nonextensible,
		helpstring("IFrame interface"),
		pointer_default(unique)
	]
	interface IFrame : IDispatch
	{
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, Style, AppearanceConstants
		[propget, id(DISPID_FRM_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_FRM_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_FRM_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_FRM_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_FRM_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \remarks This property isn't supported for themed frames.
		///
		/// \sa ForeColor
		[propget, id(DISPID_FRM_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed frames.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_FRM_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed frames.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderVisible, Style, BorderStyleConstants
		[propget, id(DISPID_FRM_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_FRM_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \brief <em>Specifies whether the control's border and caption are drawn</em>
		///
		/// Retrieves or sets whether the control's border and caption are drawn. If set to \c True, the
		/// border and caption are drawn. If set to \c False, only the control's background is drawn.
		///
		/// \sa BorderStyle, Text
		[propget, id(DISPID_FRM_BORDERVISIBLE), helpstring("Retrieves or sets whether the control's border and caption are drawn.")]
		HRESULT BorderVisible([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_FRM_BORDERVISIBLE), helpstring("Retrieves or sets whether the control's border and caption are drawn.")]
		HRESULT BorderVisible([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_FRM_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_FRM_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls the type of the control's caption</em>
		///
		/// Retrieves or sets what the control's caption consists of. Any of the values defined by the
		/// \c ContentTypeConstants enumeration is valid.
		///
		/// \sa Image, Text, ContentTypeConstants
		[propget, id(DISPID_FRM_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([out, retval] ContentTypeConstants* pValue);
		[propput, id(DISPID_FRM_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([in] ContentTypeConstants newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_FRM_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_FRM_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large
		/// changes on the control may increase performance.
		/// If set to \c False, the control will redraw itself automatically; otherwise not.
		[propget, id(DISPID_FRM_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_FRM_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_FRM_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_FRM_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the caption.
		///
		/// \sa UseSystemFont, Text, ForeColor
		[propget, id(DISPID_FRM_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_FRM_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_FRM_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \remarks This property isn't supported for themed frames.
		///
		/// \sa BackColor, Text, Font
		[propget, id(DISPID_FRM_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed frames.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_FRM_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed frames.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the horizontal alignment of the control's caption</em>
		///
		/// Retrieves or sets the horizontal alignment of the control's caption. Any of the values defined by
		/// the \c HAlignmentConstants enumeration is valid.
		///
		/// \sa Text, IconAlignment, HAlignmentConstants
		[propget, id(DISPID_FRM_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_FRM_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies the control's associated imagelist</em>
		///
		/// Retrieves or sets the handle to the imagelist containing the control's icons. If set to 0, no
		/// icon is drawn.\n
		/// The icon's index in the imagelist specifies the control state it is used for:
		/// - 0 - Used if the frame is in no special state.
		/// - 1 - Used if the frame is in 'hot' state, i. e. it's below the mouse cursor.
		/// - 2 - Currently not used.
		/// - 3 - Used if the frame is disabled.
		/// - 4 - Currently not used.
		/// - 5 - (Tablet PC specific) Currently not used.
		///
		/// If the imagelist contains only one icon, it is used for all control states. If it contains more
		/// than one, but less than five (six on Tablet PCs), no icon will be drawn if the control is in a
		/// state that no icon is specified for.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          The previously set image list does NOT get destroyed automatically.
		///
		/// \sa Image, Text, IconAlignment, UseImprovedImageListSupport, IconIndex
		[propget, id(DISPID_FRM_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_FRM_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system
		/// hover time is used.
		///
		/// \sa _IFrameEvents::MouseHover
		[propget, id(DISPID_FRM_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_FRM_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IFrameEvents::RecreatedControlWindow, _IFrameEvents::DestroyedControlWindow
		[propget, id(DISPID_FRM_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified
		/// by the \c hImageList property). Any of the values defined by the \c IconAlignmentConstants
		/// enumeration is valid.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa hImageList, HAlignment, IconAlignmentConstants
		[propget, id(DISPID_FRM_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([out, retval] IconAlignmentConstants* pValue);
		[propput, id(DISPID_FRM_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([in] IconAlignmentConstants newValue);
		/// \brief <em>Specifies the control's icons</em>
		///
		/// Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the
		/// \c hImageList property. The control can use a different icon for each control state.
		///
		/// \param[in] controlState The control state for the icon index shall be retrieved or set. If set to
		///            -1, the icon index is applied for all control states. The following control states
		///            exist:
		///            - Icon 0 - Used if the frame is in no special state.
		///            - Icon 1 - Used if the frame is in 'hot' state, i. e. it's below the mouse cursor.
		///            - Icon 2 - Currently not used.
		///            - Icon 3 - Used if the frame is disabled.
		///            - Icon 4 - Currently not used.
		///            - Icon 5 - (Tablet PC specific) Currently not used.
		///            If a state's icon index is set to -1, no icon is drawn for this state.
		///
		/// \remarks This property is ignored if the \c UseImprovedImageListSupport is set to \c False.
		///
		/// \sa UseImprovedImageListSupport, hImageList
		[propget, id(DISPID_FRM_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [out, retval] LONG* pValue);
		[propput, id(DISPID_FRM_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [in] LONG newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginLeft, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_FRM_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_FRM_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_FRM_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_FRM_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginTop, hImageList
		[propget, id(DISPID_FRM_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_FRM_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginRight, hImageList
		[propget, id(DISPID_FRM_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_FRM_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the bitmap or icon displayed as caption</em>
		///
		/// Retrieves or sets the image that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctBitmap or \c ctIcon.
		///
		/// \remarks The image does NOT get destroyed automatically by the control.\n
		///          Due to limitations in Windows' \c Button window class, frames displaying a bitmap or
		///          icon won't use Windows XP themes.
		///
		/// \sa ContentType, Text, hImageList
		[propget, id(DISPID_FRM_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, frames using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_FRM_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, frames using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([in] OLE_HANDLE newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_FRM_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_FRM_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_FRM_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_FRM_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_FRM_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_FRM_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_FRM_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IFrameEvents::OLEDragEnter
		[propget, id(DISPID_FRM_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_FRM_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_FRM_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_FRM_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Controls the control's appearance</em>
		///
		/// Retrieves or sets the control's drawing style. Any of the values defined by the \c StyleConstants
		/// enumeration is valid.
		///
		/// \sa Appearance, BorderStyle, StyleConstants
		[propget, id(DISPID_FRM_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([out, retval] StyleConstants* pValue);
		[propput, id(DISPID_FRM_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([in] StyleConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_FRM_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_FRM_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_FRM_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's caption</em>
		///
		/// Retrieves or sets the text that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctText.
		///
		/// \sa HAlignment, ForeColor, Font, ContentType, Image, hImageList
		[propget, id(DISPID_FRM_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_FRM_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Specifies whether the control uses code that makes usage of image lists easier</em>
		///
		/// The Windows native button control supports assignment of an image list to display an icon on the
		/// button, but it requires the icon to be the first one in the image list. For this reason each button
		/// needs its own image list, so the more buttons with icons are used, the more image lists have to be
		/// created and managed. This leads to bloated code.\n
		/// TimoSoft ButtonControls can work around this issue and allow the client application to specify the
		/// icons used by a button individually, so that all buttons can share the same image list. However,
		/// this feature slightly changes the control's behavior, so it must be activated explicitly to keep
		/// backward compatibility.\n
		/// If this property is set to \c True, the work-around is activated; otherwise not.
		///
		/// \remarks This property cannot be set at run-time.
		///
		/// \sa hImageList, IconIndex
		[propget, id(DISPID_FRM_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_FRM_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_FRM_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_FRM_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_FRM_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_FRM_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Clicks the frame by code</em>
		///
		/// \sa _IFrameEvents::Click
		[id(DISPID_FRM_CLICK), helpstring("Clicks the frame by code.")]
		HRESULT Click(void);
		/// \brief <em>Retrieves a bit field describing the control's state</em>
		///
		/// \return A bit field of constants defined by the \c ControlStateConstants enumeration, that
		///         describe the control's state.
		///
		/// \sa ControlStateConstants
		[id(DISPID_FRM_GETCONTROLSTATE), helpstring("Retrieves a bit field describing the control's state.")]
		HRESULT GetControlState([out, retval] ControlStateConstants* pControlState);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_FRM_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_FRM_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_FRM_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IFrameEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_FRM_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IFrameEvents
	/// \brief <em>The \c Frame class' events interface</em>
	///
	/// This interface defines all events the \c Frame class may raise.
	///
	/// \sa IFrame
	[
		uuid(B5872761-DEA9-45da-9655-43EE45687D1E),
		helpstring("IFrame-event-interface")
	]
	dispinterface _IFrameEvents
	{
		properties:
		methods:
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This is the control's default event.\n
			///          This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, IFrame::DisabledEvents
			[id(DISPID_FRME_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			///
			/// \sa RClick
			[id(DISPID_FRME_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, IFrame::DisabledEvents
			[id(DISPID_FRME_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IFrame::hWnd
			[id(DISPID_FRME_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, IFrame::DisabledEvents
			[id(DISPID_FRME_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, IFrame::DisabledEvents
			[id(DISPID_FRME_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants, IFrame::DisabledEvents
			[id(DISPID_FRME_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants, IFrame::DisabledEvents
			[id(DISPID_FRME_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IFrame::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IFrame::HoverTime, ExtendedMouseButtonConstants,
			///     IFrame::DisabledEvents
			[id(DISPID_FRME_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants, IFrame::DisabledEvents
			[id(DISPID_FRME_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, ExtendedMouseButtonConstants,
			///     IFrame::DisabledEvents
			[id(DISPID_FRME_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IFrame::DisabledEvents
			[id(DISPID_FRME_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, IFrame::RegisterForOLEDragDrop,
			///     IFrame::FinishOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_FRME_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, IFrame::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_FRME_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, IFrame::RegisterForOLEDragDrop
			[id(DISPID_FRME_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IFrame::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_FRME_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control must be drawn</em>
			///
			/// Will be fired if the \c Style property is set to \c sOwnerDrawn and the control needs to be
			/// drawn.
			///
			/// \param[in] requiredAction Specifies the required drawing action. Any combination of the values
			///            defined by the \c OwnerDrawActionConstants enumeration is valid.
			/// \param[in] controlState Specifies the control's current state (focused, selected etc.). Any
			///            combination of the values defined by the \c OwnerDrawControlStateConstants enumeration
			///            are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			///
			/// \sa IFrame::Style, RECTANGLE, OwnerDrawActionConstants, OwnerDrawControlStateConstants
			[id(DISPID_FRME_OWNERDRAW), helpstring("Will be fired if the 'Style' property is set to 'sOwnerDrawn' and the control needs to be drawn.")]
			void OwnerDraw(OwnerDrawActionConstants requiredAction, OwnerDrawControlStateConstants controlState, LONG hDC, RECTANGLE* drawingRectangle);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, IFrame::DisabledEvents
			[id(DISPID_FRME_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, IFrame::DisabledEvents
			[id(DISPID_FRME_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IFrame::hWnd
			[id(DISPID_FRME_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_FRME_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants, IFrame::DisabledEvents
			[id(DISPID_FRME_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants, IFrame::DisabledEvents
			[id(DISPID_FRME_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \brief <em>The \c Frame class</em>
	///
	/// The frame control's main COM class. It implements the \c IFrame and
	/// \c _IFrameEvents interfaces.
	///
	/// \sa IFrame, _IFrameEvents
	[
		uuid(21F7097C-BBA6-47C7-8455-04ECADB9F600),
		version(1.10),
		helpstring("Frame Control 1.10 (Unicode)")
	]
	coclass Frame
	{
		[default] interface IFrame;
		[default, source] dispinterface _IFrameEvents;
	};


	/// \interface IOptionButton
	/// \brief <em>The main interface (option button)</em>
	///
	/// This is the option button control's main interface. It wraps the control window.
	///
	/// \sa _IOptionButtonEvents
	[
		object,
		uuid(9CE8D6CD-4993-43b7-8691-9173A1D8FF33),
		dual,
		nonextensible,
		helpstring("IOptionButton interface"),
		pointer_default(unique)
	]
	interface IOptionButton : IDispatch
	{
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, PushLike, Style, AppearanceConstants
		[propget, id(DISPID_OPTBTN_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_OPTBTN_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_OPTBTN_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_OPTBTN_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_OPTBTN_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		// \brief <em>Controls how the control reacts to mouse clicks</em>
		//
		// Retrieves or sets whether the option is selected automatically if the user clicks on the control.
		// If set to \c True, it is changed automatically; otherwise not.
		//
		// \sa Selected, _IOptionButtonEvents::Click
		//[propget, id(DISPID_OPTBTN_AUTOTOGGLEOPTION), helpstring("Retrieves or sets whether the option is selected automatically if the user clicks on the control.")]
		//HRESULT AutoToggleOption([out, retval] VARIANT_BOOL* pValue);
		//[propput, id(DISPID_OPTBTN_AUTOTOGGLEOPTION), helpstring("Retrieves or sets whether the option is selected automatically if the user clicks on the control.")]
		//HRESULT AutoToggleOption([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \remarks This property isn't supported for themed option buttons.
		///
		/// \sa ForeColor
		[propget, id(DISPID_OPTBTN_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed option buttons.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_OPTBTN_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed option buttons.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, PushLike, Style, BorderStyleConstants
		[propget, id(DISPID_OPTBTN_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_OPTBTN_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_OPTBTN_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_OPTBTN_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls the type of the control's caption</em>
		///
		/// Retrieves or sets what the control's caption consists of. Any of the values defined by the
		/// \c ContentTypeConstants enumeration is valid.
		///
		/// \sa Image, Text, ContentTypeConstants
		[propget, id(DISPID_OPTBTN_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([out, retval] ContentTypeConstants* pValue);
		[propput, id(DISPID_OPTBTN_CONTENTTYPE), helpstring("Retrieves or sets what the control's caption consists of.")]
		HRESULT ContentType([in] ContentTypeConstants newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_OPTBTN_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_OPTBTN_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large
		/// changes on the control may increase performance.
		/// If set to \c False, the control will redraw itself automatically; otherwise not.
		[propget, id(DISPID_OPTBTN_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_OPTBTN_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the caption.
		///
		/// \sa UseSystemFont, Text, ForeColor
		[propget, id(DISPID_OPTBTN_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_OPTBTN_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_OPTBTN_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \remarks This property isn't supported for themed option buttons.
		///
		/// \sa BackColor, Text, Font
		[propget, id(DISPID_OPTBTN_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed option buttons.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_OPTBTN_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed option buttons.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the horizontal alignment of the control's caption</em>
		///
		/// Retrieves or sets the horizontal alignment of the control's caption. Any of the values defined by
		/// the \c HAlignmentConstants enumeration is valid.
		///
		/// \sa Text, VAlignment, IconAlignment, HAlignmentConstants
		[propget, id(DISPID_OPTBTN_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_OPTBTN_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's caption.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies the control's associated imagelist</em>
		///
		/// Retrieves or sets the handle to the imagelist containing the control's icons. If set to 0, no
		/// icon is drawn.\n
		/// The icon's index in the imagelist specifies the control state it is used for:
		/// - 0 - Used if the option button is in no special state.
		/// - 1 - Used if the option button is in 'hot' state, i. e. it's below the mouse cursor.
		/// - 2 - Used if the option button is pressed.
		/// - 3 - Used if the option button is disabled.
		/// - (4 - Used if the option button is the dialog's default button.)
		/// - 5 - Used on Tablet PCs (I don't know when).
		///
		/// If the imagelist contains only one icon, it is used for all control states. If it contains more
		/// than one, but less than five (six on Tablet PCs), no icon will be drawn if the control is in a
		/// state that no icon is specified for.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          The previously set image list does NOT get destroyed automatically.
		///
		/// \sa Image, Text, IconAlignment, UseImprovedImageListSupport, IconIndex, GetIdealSize
		[propget, id(DISPID_OPTBTN_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_OPTBTN_HIMAGELIST), helpstring("Retrieves or sets the handle to the imagelist containing the control's icons. Requires comctl32.dll version 6.0 or higher."), nonbrowsable]
		HRESULT hImageList([in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system
		/// hover time is used.
		///
		/// \sa _IOptionButtonEvents::MouseHover
		[propget, id(DISPID_OPTBTN_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_OPTBTN_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IOptionButtonEvents::RecreatedControlWindow, _IOptionButtonEvents::DestroyedControlWindow
		[propget, id(DISPID_OPTBTN_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified
		/// by the \c hImageList property). Any of the values defined by the \c IconAlignmentConstants
		/// enumeration is valid.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa hImageList, HAlignment, VAlignment, IconAlignmentConstants
		[propget, id(DISPID_OPTBTN_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([out, retval] IconAlignmentConstants* pValue);
		[propput, id(DISPID_OPTBTN_ICONALIGNMENT), helpstring("Retrieves or sets the alignment of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconAlignment([in] IconAlignmentConstants newValue);
		/// \brief <em>Specifies the control's icons</em>
		///
		/// Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the
		/// \c hImageList property. The control can use a different icon for each control state.
		///
		/// \param[in] controlState The control state for the icon index shall be retrieved or set. If set to
		///            -1, the icon index is applied for all control states. The following control states
		///            exist:
		///            - Icon 0 - Used if the option button is in no special state.
		///            - Icon 1 - Used if the option button is in 'hot' state, i. e. it's below the mouse cursor.
		///            - Icon 2 - Used if the option button is pressed.
		///            - Icon 3 - Used if the option button is disabled.
		///            - (Icon 4 - Used if the option button is the dialog's default button.)
		///            - Icon 5 - Used on Tablet PCs (I don't know when).
		///            If a state's icon index is set to -1, no icon is drawn for this state.
		///
		/// \remarks This property is ignored if the \c UseImprovedImageListSupport is set to \c False.
		///
		/// \sa UseImprovedImageListSupport, hImageList
		[propget, id(DISPID_OPTBTN_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [out, retval] LONG* pValue);
		[propput, id(DISPID_OPTBTN_ICONINDEX), helpstring("Retrieves or sets the zero-based indexes of the control's icons in the image list specified by the 'hImageList' property. This property is ignored if the 'UseImprovedImageListSupport' is set to 'False'.")]
		HRESULT IconIndex([in, defaultvalue(-1)] LONG controlState, [in] LONG newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginLeft, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_OPTBTN_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_ICONMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginBottom([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginRight, IconMarginTop, hImageList
		[propget, id(DISPID_OPTBTN_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_ICONMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginLeft([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginTop, hImageList
		[propget, id(DISPID_OPTBTN_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_ICONMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginRight([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's icon</em>
		///
		/// Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the
		/// imagelist specified by the \c hImageList property).
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IconMarginBottom, IconMarginLeft, IconMarginRight, hImageList
		[propget, id(DISPID_OPTBTN_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_ICONMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's icon (which is taken from the imagelist specified by the 'hImageList' property). Requires comctl32.dll version 6.0 or higher.")]
		HRESULT IconMarginTop([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the bitmap or icon displayed as caption</em>
		///
		/// Retrieves or sets the image that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctBitmap or \c ctIcon.
		///
		/// \remarks The image does NOT get destroyed automatically by the control.\n
		///          Due to limitations in Windows' \c Button window class, option buttons displaying a bitmap
		///          or icon won't use Windows XP themes.
		///
		/// \sa ContentType, Text, hImageList
		[propget, id(DISPID_OPTBTN_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, option buttons using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_OPTBTN_IMAGE), helpstring("Retrieves or sets the image that is displayed as the control's caption if the 'ContentType' property is set to 'ctBitmap' or 'ctIcon'. Due to limitations in Windows' 'Button' window class, option buttons using this style won't use Windows XP themes."), nonbrowsable]
		HRESULT Image([in] OLE_HANDLE newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_OPTBTN_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_OPTBTN_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_OPTBTN_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_OPTBTN_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_OPTBTN_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_OPTBTN_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the control displays text in multiple lines</em>
		///
		/// Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to
		/// fit on a single line. If set to \c True, the text may be wrapped; otherwise not.
		///
		/// \sa Text
		[propget, id(DISPID_OPTBTN_MULTILINE), helpstring("Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to fit on a single line..")]
		HRESULT MultiLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_MULTILINE), helpstring("Retrieves or sets whether the control's caption is wrapped to multiple lines if it is too long to fit on a single line.")]
		HRESULT MultiLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the option mark's location relative to the control's caption</em>
		///
		/// Retrieves or sets whether the control's option mark is drawn to the right of the text specified by
		/// the \c Text property. If set to \c True, it is drawn to the right; otherwise to the left.
		///
		/// \sa RightToLeft, Text
		[propget, id(DISPID_OPTBTN_OPTIONMARKONRIGHT), helpstring("Retrieves or sets whether the control's option mark is drawn to the right of the text specified by the 'Text' property.")]
		HRESULT OptionMarkOnRight([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_OPTIONMARKONRIGHT), helpstring("Retrieves or sets whether the control's option mark is drawn to the right of the text specified by the 'Text' property.")]
		HRESULT OptionMarkOnRight([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the event gets fired; otherwise not.
		///
		/// \sa _IOptionButtonEvents::ContextMenu
		[propget, id(DISPID_OPTBTN_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_OPTBTN_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the control is drawn like being pushed</em>
		///
		/// Retrieves or sets whether the option button is drawn like being pushed. If set to \c True, it is
		/// drawn like being pushed; otherwise not.
		///
		/// \sa Click, GetControlState
		[propget, id(DISPID_OPTBTN_PUSHED), helpstring("Retrieves or sets whether the option button is drawn like being pushed.")]
		HRESULT Pushed([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_PUSHED), helpstring("Retrieves or sets whether the option button is drawn like being pushed.")]
		HRESULT Pushed([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's appearance</em>
		///
		/// Retrieves or sets whether the option buttion is drawn like a push button. If set to \c True, it is
		/// drawn like a push button; otherwise it is drawn like a common option button.
		///
		/// \sa Appearance, BorderStyle, Style
		[propget, id(DISPID_OPTBTN_PUSHLIKE), helpstring("Retrieves or sets whether the option buttion is drawn like a push button.")]
		HRESULT PushLike([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_PUSHLIKE), helpstring("Retrieves or sets whether the option buttion is drawn like a push button.")]
		HRESULT PushLike([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IOptionButtonEvents::OLEDragEnter
		[propget, id(DISPID_OPTBTN_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa OptionMarkOnRight, RightToLeftConstants
		[propget, id(DISPID_OPTBTN_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_OPTBTN_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the state of the control's option mark</em>
		///
		/// Retrieves or sets whether the option represented by this option buttion is selected or not. If
		/// this property is set to \c True, the option is selected; otherwise not.
		///
		// \sa AutoToggleOption, GetControlState, _IOptionButtonEvents::SelectionChanged
		/// \sa GetControlState, _IOptionButtonEvents::SelectionChanged
		[propget, id(DISPID_OPTBTN_SELECTED), helpstring("Retrieves or sets whether the option represented by this option buttion is selected or not."), bindable, immediatebind, requestedit, displaybind, defaultbind]
		HRESULT Selected([out, retval] OLE_OPTEXCLUSIVE* pValue);
		[propput, id(DISPID_OPTBTN_SELECTED), helpstring("Retrieves or sets whether the option represented by this option buttion is selected or not."), bindable, immediatebind, requestedit, displaybind, defaultbind]
		HRESULT Selected([in] OLE_OPTEXCLUSIVE newValue);
		/// \brief <em>Controls the control's appearance</em>
		///
		/// Retrieves or sets the control's drawing style. Any of the values defined by the \c StyleConstants
		/// enumeration is valid.
		///
		/// \sa Appearance, BorderStyle, PushLike, StyleConstants
		[propget, id(DISPID_OPTBTN_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([out, retval] StyleConstants* pValue);
		[propput, id(DISPID_OPTBTN_STYLE), helpstring("Retrieves or sets the control's drawing style.")]
		HRESULT Style([in] StyleConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_OPTBTN_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_OPTBTN_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's caption</em>
		///
		/// Retrieves or sets the text that is displayed as the control's caption if the \c ContentType
		/// property is set to \c ctText.
		///
		/// \sa HAlignment, VAlignment, MultiLine, ForeColor, Font, ContentType, Image, hImageList,
		///     GetIdealSize
		[propget, id(DISPID_OPTBTN_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_OPTBTN_TEXT), helpstring("Retrieves or sets the text that is displayed as the control's caption if the 'ContentType' property is set to 'ctText'."), bindable, requestedit, displaybind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the bottom margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginLeft, TextMarginRight, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_OPTBTN_TEXTMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginBottom([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_TEXTMARGINBOTTOM), helpstring("Retrieves or sets the bottom margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginBottom([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the left margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginBottom, TextMarginRight, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_OPTBTN_TEXTMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginLeft([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_TEXTMARGINLEFT), helpstring("Retrieves or sets the left margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginLeft([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the right margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginBottom, TextMarginLeft, TextMarginTop, Text, GetIdealSize
		[propget, id(DISPID_OPTBTN_TEXTMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginRight([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_TEXTMARGINRIGHT), helpstring("Retrieves or sets the right margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginRight([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the location of the control's caption</em>
		///
		/// Retrieves or sets the top margin (in pixels) of the control's text.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows don't seem to support text margins.
		///
		/// \sa TextMarginBottom, TextMarginLeft, TextMarginRight, Text, GetIdealSize
		[propget, id(DISPID_OPTBTN_TEXTMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginTop([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_OPTBTN_TEXTMARGINTOP), helpstring("Retrieves or sets the top margin (in pixels) of the control's text. Requires comctl32.dll version 6.0 or higher. Current versions of Windows don't seem to support text margins.")]
		HRESULT TextMarginTop([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether the control uses code that makes usage of image lists easier</em>
		///
		/// The Windows native button control supports assignment of an image list to display an icon on the
		/// button, but it requires the icon to be the first one in the image list. For this reason each button
		/// needs its own image list, so the more buttons with icons are used, the more image lists have to be
		/// created and managed. This leads to bloated code.\n
		/// TimoSoft ButtonControls can work around this issue and allow the client application to specify the
		/// icons used by a button individually, so that all buttons can share the same image list. However,
		/// this feature slightly changes the control's behavior, so it must be activated explicitly to keep
		/// backward compatibility.\n
		/// If this property is set to \c True, the work-around is activated; otherwise not.
		///
		/// \remarks This property cannot be set at run-time.
		///
		/// \sa hImageList, IconIndex
		[propget, id(DISPID_OPTBTN_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_USEIMPROVEDIMAGELISTSUPPORT), helpstring("Specifies whether the control uses code that makes usage of image lists easier. This property cannot be set at run-time.")]
		HRESULT UseImprovedImageListSupport([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_OPTBTN_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_OPTBTN_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the vertical alignment of the control's caption</em>
		///
		/// Retrieves or sets the vertical alignment of the control's caption. Any of the values defined by the
		/// \c VAlignmentConstants enumeration is valid.
		///
		/// \sa Text, HAlignment, IconAlignment, VAlignmentConstants
		[propget, id(DISPID_OPTBTN_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the control's caption.")]
		HRESULT VAlignment([out, retval] VAlignmentConstants* pValue);
		[propput, id(DISPID_OPTBTN_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the control's caption.")]
		HRESULT VAlignment([in] VAlignmentConstants newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_OPTBTN_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_OPTBTN_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Clicks the option button by code</em>
		///
		/// \sa _IOptionButtonEvents::Click
		[id(DISPID_OPTBTN_CLICK), helpstring("Clicks the option button by code.")]
		HRESULT Click(void);
		/// \brief <em>Retrieves a bit field describing the control's state</em>
		///
		/// \return A bit field of constants defined by the \c ControlStateConstants enumeration, that
		///         describe the control's state.
		///
		/// \sa Pushed, Selected, ControlStateConstants
		[id(DISPID_OPTBTN_GETCONTROLSTATE), helpstring("Retrieves a bit field describing the control's state.")]
		HRESULT GetControlState([out, retval] ControlStateConstants* pControlState);
		/// \brief <em>Retrieves the control's optimal size</em>
		///
		/// Calculates the rectangle that best fits the control's text and image, if an imagelist is present.
		///
		/// \param[out] idealWidth The control's optimal width in pixels.
		/// \param[out] idealHeight The control's optimal height in pixels.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text, hImageList, TextMarginBottom, TextMarginLeft, TextMarginRight, TextMarginTop
		[id(DISPID_OPTBTN_GETIDEALSIZE), helpstring("Calculates the rectangle that best fits the control's text and image, if an imagelist is present. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT GetIdealSize([in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* idealWidth, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* idealHeight);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_OPTBTN_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_OPTBTN_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_OPTBTN_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IOptionButtonEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_OPTBTN_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IOptionButtonEvents
	/// \brief <em>The \c OptionButton class' events interface</em>
	///
	/// This interface defines all events the \c OptionButton class may raise.
	///
	/// \sa IOptionButton
	[
		uuid(0B6EB400-C291-4113-B7AE-8AFB544DF728),
		helpstring("IOptionButton-event-interface")
	]
	dispinterface _IOptionButtonEvents
	{
		properties:
		methods:
			/// \brief <em>The control's selection state was changed</em>
			///
			/// Will be fired after the control's selection state was changed.
			///
			/// \param[in] previousSelectionState The control's previous selection state.
			/// \param[in] newSelectionState The control's new selection state.
			///
			/// \sa IOptionButton::Selected
			[id(DISPID_OPTBTNE_SELECTIONCHANGED), helpstring("Will be fired after the control's selection state was changed.")]
			void SelectionChanged(VARIANT_BOOL previousSelectionState, VARIANT_BOOL newSelectionState);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			///
			/// \sa RClick
			[id(DISPID_OPTBTNE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>Custom drawing should be done here</em>
			///
			/// Will be fired after the control processed a \c NM_CUSTOMDRAW notification allowing custom
			/// drawing of the control's content.
			///
			/// \param[in] drawStage Specifies the stage of custom drawing this event was raised for. Any of
			///            the values defined by the \c CustomDrawStageConstants enumeration is valid.
			/// \param[in] controlState Specifies the control's current state (focused, selected etc.). Most of
			///            the values defined by the \c CustomDrawControlStateConstants enumeration are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			/// \param[in,out] furtherProcessing Controls further drawing. Most of the values defined by the
			///                \c CustomDrawReturnValuesConstants enumeration are valid.
			///
			/// \remarks Requires comctl32.dll version 6.0 or higher.\n
			///          This event may be disabled.
			///
			/// \sa OwnerDraw, RECTANGLE, CustomDrawStageConstants, CustomDrawControlStateConstants,
			///     CustomDrawReturnValuesConstants, IOptionButton::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms673590.aspx">NM_CUSTOMDRAW (button)</a>
			[id(DISPID_OPTBTNE_CUSTOMDRAW), helpstring("Will be fired after the control processed a 'NM_CUSTOMDRAW' notification allowing custom drawing of the control. Requires comctl32.dll version 6.0 or higher. This event may be disabled.")]
			void CustomDraw(CustomDrawStageConstants drawStage, CustomDrawControlStateConstants controlState, LONG hDC, RECTANGLE* drawingRectangle, CustomDrawReturnValuesConstants* furtherProcessing);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IOptionButton::hWnd
			[id(DISPID_OPTBTNE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IOptionButton::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IOptionButton::HoverTime, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp,
			///     IOptionButton::RegisterForOLEDragDrop, IOptionButton::FinishOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_OPTBTNE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter,
			///     IOptionButton::RegisterForOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_OPTBTNE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave,
			///     IOptionButton::RegisterForOLEDragDrop
			[id(DISPID_OPTBTNE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IOptionButton::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_OPTBTNE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control must be drawn</em>
			///
			/// Will be fired if the \c Style property is set to \c sOwnerDrawn and the control needs to be
			/// drawn.
			///
			/// \param[in] requiredAction Specifies the required drawing action. Any combination of the values
			///            defined by the \c OwnerDrawActionConstants enumeration is valid.
			/// \param[in] controlState Specifies the control's current state (focused, selected etc.). Any
			///            combination of the values defined by the \c OwnerDrawControlStateConstants enumeration
			///            are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			///
			/// \sa IOptionButton::Style, CustomDraw, RECTANGLE, OwnerDrawActionConstants,
			///     OwnerDrawControlStateConstants
			[id(DISPID_OPTBTNE_OWNERDRAW), helpstring("Will be fired if the 'Style' property is set to 'sOwnerDrawn' and the control needs to be drawn.")]
			void OwnerDraw(OwnerDrawActionConstants requiredAction, OwnerDrawControlStateConstants controlState, LONG hDC, RECTANGLE* drawingRectangle);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IOptionButton::hWnd
			[id(DISPID_OPTBTNE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_OPTBTNE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants,
			///     IOptionButton::DisabledEvents
			[id(DISPID_OPTBTNE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \brief <em>The \c OptionButton class</em>
	///
	/// The option button control's main COM class. It implements the \c IOptionButton and
	/// \c _IOptionButtonEvents interfaces.
	///
	/// \sa IOptionButton, _IOptionButtonEvents
	[
		uuid(24771C29-C614-4092-A3FE-59CAE19C837B),
		version(1.10),
		helpstring("OptionButton Control 1.10 (Unicode)")
	]
	coclass OptionButton
	{
		[default] interface IOptionButton;
		[default, source] dispinterface _IOptionButtonEvents;
	};


	[
		uuid(67D2FB88-FD81-412c-A467-031DEFF2D074),
		version(1.10),
		noncreatable,
		helpstring("CommonProperties Class 1.10 (Unicode)"),
		hidden
	]
	coclass CommonProperties
	{
		[default] interface IUnknown;
	};


	[
		uuid(A785AD5B-6702-45b1-AF20-B5A177C0CAF6),
		version(1.10),
		noncreatable,
		helpstring("StringProperties Class 1.10 (Unicode)"),
		hidden
	]
	coclass StringProperties
	{
		[default] interface IUnknown;
	};
};
